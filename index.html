<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Box Fighter</title>
  <link rel="icon" type="image/png" href="favicon.ico">
  <!-- Import font and Socket.IO library -->
  <link href="https://fonts.googleapis.com/css?family=Poppins:400,600&display=swap" rel="stylesheet">
  <script src="https://cdn.socket.io/4.5.1/socket.io.min.js"></script>
  <style>
    /* === Global Styles === */
    body,
    html {
      margin: 0;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
      height: 100%;
      background-color: #1e1e1e;
    }
    /* Main Menu Styling */
    #startMenu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      z-index: 100;
      user-select: none;
    }
    #studiosText {
      font-size: 24px;
      background: linear-gradient(45deg, #ff6b6b, #ffcd3c, #6b94ff, #6bffb8);
      -webkit-background-clip: text;
      color: transparent;
      animation: gradient-text 4s linear infinite;
      margin-bottom: 20px;
    }
    #menuCoinCounter {
      position: absolute;
      top: 50px;
      right: 5px;
      border: 2px solid gold;
      padding: 6px;
      border-radius: 10px;
      font-size: 17px;
      background: rgba(0, 0, 0, 0.5);
      color: gold;
      z-index: 110;
    }
    #menuGunShopButton,
    #gameModeButton,
    button {
      font-size: 20px;
      padding: 10px 20px;
      background-color: #344;
      border: 2px solid white;
      color: white;
      cursor: pointer;
      border-radius: 50px;
      transition: transform 0.5s ease, background-color 0.5s ease;
      margin-top: 15px;
    }
    #menuGunShopButton:hover,
    #gameModeButton:hover,
    button:hover {
      background-color: #ff6b6b;
      transform: scale(1.2);
    }
    #menuGunShopButton:active,
    #gameModeButton:active,
    button:active {
      transform: scale(1.05);
    }
    h1 {
      font-size: 80px;
      text-align: center;
      background: linear-gradient(45deg, #ff6b6b, #ffcd3c, #6b94ff, #6bffb8);
      -webkit-background-clip: text;
      color: transparent;
      animation: gradient-text 3s linear infinite, pulsate 2s ease-in-out infinite;
      margin-bottom: 30px;
    }
    @keyframes pulsate {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    @keyframes gradient-text {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    #muteButton {
      position: fixed;
      top: -15px;
      right: 5px;
      z-index: 110;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #222;
      border: 2px solid #fff;
      border-radius: 5px;
      user-select: none;
    }
    /* Game UI */
    #gameUI {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      z-index: 10;
      display: none;
    }
    #healthBar {
      width: 250px;
      height: 30px;
      border: 3px solid white;
      margin-bottom: 10px;
      border-radius: 5px;
    }
    #healthBarInner {
      height: 100%;
      background-color: green;
      transition: width 0.3s;
    }
    /* Boss Health Bars */
    #bossHealthBarContainer {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      z-index: 15;
      display: none;
    }
    .bossHealthBar {
      height: 30px;
      background-color: darkred;
      border: 3px solid white;
      border-radius: 20px;
      margin: 5px 0;
      transition: width 0.3s;
    }
    /* Canvas Background */
    canvas {
      display: block;
      background: url('https://i.postimg.cc/C1dhpGkh/1348017.png') no-repeat center center fixed;
      background-size: cover;
      touch-action: none;
    }
    /* Game Over Screen */
    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 100;
      user-select: none;
    }
    #gameOverGunShopButton {
      font-size: 20px;
      padding: 10px 20px;
      background-color: #344;
      border: 2px solid white;
      color: white;
      cursor: pointer;
      border-radius: 50px;
      transition: transform 0.5s ease, background-color 0.5s ease;
      margin-top: 15px;
    }
    #gameOverGunShopButton:hover {
      background-color: #ff6b6b;
      transform: scale(1.2);
    }
    #gameOverGunShopButton:active {
      transform: scale(1.05);
    }
    #gameOverCoinCounter {
      border: 2px solid gold;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 25px;
      background: rgba(0, 0, 0, 0.5);
      color: gold;
      margin: 10px 0;
    }
    /* Color Picker */
    #colorPickerContainer {
      margin: 20px 0;
      text-align: center;
    }
    #colorPickerContainer label {
      color: silver;
      margin-right: 20px;
    }
    #colorPreview {
      width: 40px;
      height: 40px;
      margin: 10px auto;
    }
    /* Leaderboard */
    #leaderboard {
      background-color: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      max-height: 200px;
      overflow-y: auto;
    }
    #leaderboard h2 {
      margin: 0 0 10px 0;
      color: #ff6b6b;
    }
    #leaderboardList {
      list-style: none;
      padding: 0;
      margin: 0;
      user-select: none;
    }
    #leaderboardList li {
      color: white;
      font-size: 18px;
      padding: 5px 10px;
      margin: 5px 0;
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 5px;
      user-select: none;
    }
    /* Round / Wave / Boss Message */
    #roundMessage {
      position: absolute;
      top: 20%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      font-weight: 600;
      color: black;
      background: white;
      border: 2px solid white;
      border-radius: 15px;
      padding: 10px 20px;
      z-index: 50;
      opacity: 0;
      transition: opacity 2s ease-in-out;
      user-select: none;
    }
    /* Gun Shop Modal & Game Mode Modal */
    #gunShopModal, #gameModeModal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      border: 3px solid white;
      padding: 20px;
      border-radius: 10px;
      z-index: 200;
      display: none;
      color: white;
      text-align: center;
      width: 300px;
      user-select: none;
    }
    #gunShopModal h2, #gameModeModal h2 {
      margin-top: 0;
    }
    .gunOption, .gameModeOption {
      border: 2px solid white;
      border-radius: 8px;
      padding: 10px;
      margin: 10px 0;
      cursor: pointer;
      transition: background 0.3s ease;
      user-select: none;
    }
    .gunOption:hover, .gameModeOption:hover {
      background: #444;
    }
    #closeGunShop, #closeGameMode {
      margin-top: 15px;
      padding: 5px 10px;
      border: none;
      background: #ff6b6b;
      color: white;
      cursor: pointer;
      border-radius: 5px;
      user-select: none;
    }
    /* Challenge Mode Timer */
    #challengeTimer {
      position: absolute;
      top: 70px;
      left: 10px;
      font-size: 20px;
      background: #000;
      padding: 5px 10px;
      color: white;
      z-index: 20;
      display: none;
      border-radius: 10px;
      user-select: none;
    }
    /* Shield Cooldown Box */
    #shieldCooldownBox {
      position: fixed;
      top: 15%;
      left: 10px;
      transform: translateY(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: #00ffff;
      padding: 10px 20px;
      border: 2px solid #00ffff;
      border-radius: 10px;
      font-size: 20px;
      z-index: 120;
      display: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <!-- Audio Elements -->
  <audio id="bgMusic" src="music.mp3" loop preload="auto"></audio>
  <audio id="enemyKillSound" src="enemy-kill.mp3" preload="auto"></audio>
  <audio id="shootSound" src="shoot.mp3" preload="auto"></audio>
  <!-- Mute Button -->
  <button id="muteButton" onclick="toggleMusic()">Mute Music</button>
  <!-- Main Menu -->
  <div id="startMenu">
    <div id="menuCoinCounter">Coins: 0</div>
    <h1>Box Fighter</h1>
    <div id="studiosText">DanCodeRoman Studios</div>
    <button onclick="startGame()">Ready Up</button>
    <button id="gameModeButton" onclick="openGameModeBox()">Game Mode</button>
    <div id="colorPickerContainer">
      <label for="playerColor">Choose Agent:</label>
      <input type="color" id="playerColor" value="#39ff14" />
      <div id="colorPreview">
        <img src="player.png" style="width:40px;height:40px;filter: drop-shadow(0 0 10px #39ff14);" />
      </div>
    </div>
  </div>
  <!-- Game Over Screen -->
  <div id="gameOverScreen">
    <h1>Game Over</h1>
    <div id="gameOverCoinCounter">Coins: 0</div>
    <p id="finalScore">Final Score: 0</p>
    <div id="leaderboard">
      <h2>Top Scores</h2>
      <ol id="leaderboardList"></ol>
    </div>
    <button onclick="restartGame()">Restart</button>
    <button id="gameOverGunShopButton" onclick="openGunShop()">Gun Shop</button>
  </div>
  <!-- Gun Shop Modal -->
  <div id="gunShopModal">
    <h2>Gun Shop</h2>
    <div class="gunOption" onclick="selectGun('rifle')">
      <strong>Rifle</strong><br>(Free) - Default single shot.
    </div>
    <div class="gunOption" onclick="selectGun('shotgun')">
      <strong>Shotgun</strong><br>(300 Coins) - 3-shot spread.
    </div>
    <div class="gunOption" onclick="selectGun('flamethrower')">
      <strong>Flamethrower</strong><br>(1000 Coins) - Hold down to continuously shoot.
    </div>
    <div class="gunOption" onclick="selectGun('uzi')">
      <strong>Uzi</strong><br>(2000 Coins) - Burst fire of 5 bullets.
    </div>
    <div class="gunOption" onclick="selectGun('shield')">
      <strong>Shield</strong><br>(5000 Coins) - Protects against enemy collisions and bullets.
    </div>
    <button id="closeGunShop" onclick="closeGunShop()">Close</button>
  </div>
  <!-- Game Mode Modal -->
  <div id="gameModeModal">
    <h2>Select Game Mode</h2>
    <div class="gameModeOption" onclick="selectGameMode('zombies')">
      <strong>Zombies</strong>
      <p>Classic waves with increasing difficulty.</p>
    </div>
    <div class="gameModeOption" onclick="selectGameMode('challenge')">
      <strong>Challenge Mode</strong>
      <p>Survive for 5 minutes! Enemies spawn every second.</p>
    </div>
    <div class="gameModeOption" onclick="selectGameMode('pvp')">
      <strong>PVP</strong>
      <p>1v1 Multiplayer battle mode.</p>
    </div>
    <button id="closeGameMode" onclick="closeGameMode()">Close</button>
  </div>
  <!-- In-Game UI -->
  <div id="gameUI">
    <div id="healthBar">
      <div id="healthBarInner"></div>
    </div>
    <p id="score" style="user-select: none;">Score: 0</p>
  </div>
  <!-- Challenge Mode Timer -->
  <p id="challengeTimer"></p>
  <!-- Boss Health Bars -->
  <div id="bossHealthBarContainer">
    <div class="bossHealthBar" id="bossHealthBar1"></div>
    <div class="bossHealthBar" id="bossHealthBar2" style="display:none;"></div>
  </div>
  <!-- Shield Cooldown Box -->
  <div id="shieldCooldownBox"></div>
  <!-- Canvas -->
  <canvas id="gameCanvas"></canvas>
  <!-- Round Message -->
  <div id="roundMessage"></div>
  <!-- Respawn Timer (hidden by default) -->
  <div id="respawnTimer" style="display:none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px;"></div>
  
  <script>
    /* ========= Game Variables & Setup ========= */
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    canvas.addEventListener("contextmenu", (e) => e.preventDefault());

    // Global game variables
    let enemyBullets = [],
        otherBullets = [],
        keys = {},
        health = 100,
        score = 0,
        enemies = [],
        healthBoosts = [],
        coinsOnField = [],
        gameLoopId,
        gameStarted = false,
        roundNumber = 1,
        nextWaveTime = performance.now(),
        waveInterval = 15000,
        waveMessageDuration = 3000,
        waveStarted = false,
        enemiesSpawnedForWave = false,
        waveStartTime = 0,
        welcomePhase = true,
        welcomePhaseEndTime = 0,
        gameMode = "zombies",
        challengeStartTime = 0,
        lastChallengeSpawnTime = 0,
        challengeTimerActive = false,
        paused = false,
        shieldEquipped = false,
        shieldActive = false,
        shieldDurability = 0,
        shieldCooldownActive = false,
        shieldCooldownStart = 0,
        coinCount = parseInt(localStorage.getItem("coinCount")) || 0,
        ownedGuns = JSON.parse(localStorage.getItem("ownedGuns")) || ["rifle"];

    // Global Socket.IO & remote players object
    const socket = io("https://boxfighter.onrender.com/");
    let otherPlayers = {};

    // Update coin counters
    function updateCoinCounters() {
      document.getElementById("menuCoinCounter").textContent = `Coins: ${coinCount * 50}`;
      document.getElementById("gameOverCoinCounter").textContent = `Coins: ${coinCount * 50}`;
    }
    updateCoinCounters();

    // Create player image and object
    const playerImage = new Image();
    playerImage.src = 'player.png';
    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 40,
      color: "#39ff14",
      bullets: []
    };

    // Mouse position for aiming
    let mousePos = { x: player.x, y: player.y };
    document.addEventListener("mousemove", (e) => {
      mousePos = { x: e.clientX, y: e.clientY };
    });

    // Color picker
    const colorPicker = document.getElementById("playerColor");
    const colorPreview = document.getElementById("colorPreview");
    colorPicker.addEventListener("input", (e) => {
      player.color = e.target.value;
      colorPreview.innerHTML = `<img src="player.png" style="width:40px;height:40px;filter: drop-shadow(0 0 10px ${e.target.value});" />`;
    });

    // Leaderboard
    let leaderboard = JSON.parse(localStorage.getItem("leaderboard") || "[]");
    function displayLeaderboard() {
      const list = document.getElementById("leaderboardList");
      list.innerHTML = "";
      leaderboard.forEach((score, i) => {
        const li = document.createElement("li");
        li.textContent = `${i + 1}. ${score}`;
        list.appendChild(li);
      });
    }
    displayLeaderboard();

    // Sound effects
    const enemyKillSound = document.getElementById("enemyKillSound");
    function playEnemyKillSound() {
      const clone = enemyKillSound.cloneNode();
      clone.volume = 1.0;
      clone.play().catch(() => {});
    }
    const shootSound = document.getElementById("shootSound");
    const shootSoundPool = [];
    const poolSize = 5;
    let poolIndex = 0;
    for (let i = 0; i < poolSize; i++) {
      shootSoundPool.push(shootSound.cloneNode());
    }
    function playShootSound() {
      const sound = shootSoundPool[poolIndex];
      poolIndex = (poolIndex + 1) % poolSize;
      sound.currentTime = 0;
      sound.play().catch(err => console.error(err));
    }

    // Accelerometer support for mobile
    let baseGamma = null, baseBeta = null;
    const sensitivity = 0.2;
    function handleOrientation(event) {
      if (baseGamma === null || baseBeta === null) {
        baseGamma = event.gamma;
        baseBeta = event.beta;
        return;
      }
      const relGamma = event.gamma - baseGamma;
      const relBeta = event.beta - baseBeta;
      player.x += relGamma * sensitivity;
      player.y += relBeta * sensitivity;
      player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, player.x));
      player.y = Math.max(player.size/2, Math.min(canvas.height - player.size/2, player.y));
    }
    function enableAccelerometerControls() {
      if (window.DeviceOrientationEvent) {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          DeviceOrientationEvent.requestPermission().then(state => {
            if (state === 'granted') window.addEventListener("deviceorientation", handleOrientation);
          }).catch(console.error);
        } else {
          window.addEventListener("deviceorientation", handleOrientation);
        }
      }
    }
    if (/Mobi|Android/i.test(navigator.userAgent)) enableAccelerometerControls();

    // Utility: Get a random spawn position
    function getRandomSpawnPosition(minDistance = 200) {
      let x, y;
      do {
        x = Math.random() * canvas.width;
        y = Math.random() * canvas.height;
      } while (Math.hypot(x - player.x, y - player.y) < minDistance);
      return { x, y };
    }

    // Update boss health bars
    function updateBossHealthBars() {
      const container = document.getElementById("bossHealthBarContainer");
      const bosses = enemies.filter(e => e.type === "boss");
      if (!bosses.length) {
        container.style.display = "none";
      } else {
        container.style.display = "block";
        if (bosses.length === 1) {
          const bar1 = document.getElementById("bossHealthBar1");
          bar1.style.width = (bosses[0].hitsRemaining / 85 * 100) + "%";
          bar1.style.display = "block";
          document.getElementById("bossHealthBar2").style.display = "none";
        } else if (bosses.length === 2) {
          const bar1 = document.getElementById("bossHealthBar1");
          const bar2 = document.getElementById("bossHealthBar2");
          bar1.style.width = (bosses[0].hitsRemaining / 85 * 100) + "%";
          bar2.style.width = (bosses[1].hitsRemaining / 85 * 100) + "%";
          bar1.style.display = "block";
          bar2.style.display = "block";
        }
      }
    }

    // Game pause
    function pauseGame() {
      if (document.getElementById("gameOverScreen").style.display !== "none") return;
      if (!paused) {
        paused = true;
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
        document.getElementById("bgMusic").pause();
        document.getElementById("startMenu").style.display = "flex";
        document.getElementById("gameUI").style.display = "none";
        document.getElementById("challengeTimer").style.display = "none";
      }
    }

    // Start game (handles resetting state and pvp mode)
    function startGame() {
      canvas.style.cursor = "url('https://i.postimg.cc/gk1NVmNN/output-onlinepngtools.png') 30 30, crosshair";
      if (paused) {
        paused = false;
        document.getElementById("startMenu").style.display = "none";
        document.getElementById("gameUI").style.display = "block";
        if (gameMode === "challenge") {
          const pauseDuration = performance.now() - pausedTime;
          challengeStartTime += pauseDuration;
          document.getElementById("challengeTimer").style.display = "block";
          challengeTimerActive = true;
        }
        document.getElementById("bgMusic").play();
        gameLoop();
        return;
      }
      if (gameLoopId) cancelAnimationFrame(gameLoopId);
      if (/Mobi|Android/i.test(navigator.userAgent)) {
        if (typeof DeviceOrientationEvent.requestPermission === "function") {
          DeviceOrientationEvent.requestPermission().then(state => {
            if (state === "granted") window.addEventListener("deviceorientation", handleOrientation);
          }).catch(console.error);
        } else {
          window.addEventListener("deviceorientation", handleOrientation);
        }
      }
      const bgMusic = document.getElementById("bgMusic");
      bgMusic.currentTime = 0;
      bgMusic.play();
      document.getElementById("startMenu").style.display = "none";
      document.getElementById("gameUI").style.display = "block";
      document.getElementById("gameOverScreen").style.display = "none";
      document.getElementById("bossHealthBarContainer").style.display = "none";
      health = 100;
      score = 0;
      enemies = [];
      healthBoosts = [];
      coinsOnField = [];
      enemyBullets = [];
      roundNumber = 1;
      nextWaveTime = performance.now();
      waveStarted = false;
      enemiesSpawnedForWave = false;
      if (gameMode !== "challenge" && gameMode !== "pvp") {
        welcomePhase = true;
        welcomePhaseEndTime = performance.now() + 5000;
        document.getElementById("roundMessage").textContent = "Welcome Agent B-XFTR";
        document.getElementById("roundMessage").style.opacity = 1;
        document.getElementById("challengeTimer").style.display = "none";
      } else if (gameMode === "challenge") {
        welcomePhase = false;
        document.getElementById("roundMessage").style.opacity = 0;
        challengeStartTime = performance.now();
        lastChallengeSpawnTime = performance.now();
        challengeTimerActive = true;
        document.getElementById("challengeTimer").style.display = "block";
      } else if (gameMode === "pvp") {
        document.getElementById("roundMessage").textContent = "PVP Mode: Waiting for opponent...";
        document.getElementById("roundMessage").style.opacity = 1;
        socket.emit('playerMove', { x: player.x, y: player.y });
      }
      gameStarted = true;
      displayLeaderboard();
      gameLoop();
    }

    function restartGame() {
      startGame();
    }

    // Spawn a health boost with 25% chance
    function spawnHealthBoost() {
      if (Math.random() < 0.25) {
        healthBoosts.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: 13,
          color: "hotpink"
        });
      }
    }

    // Spawn a coin with 25% chance
    function spawnCoin() {
      if (Math.random() < 0.25) {
        coinsOnField.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: 10,
          color: "goldenrod"
        });
      }
    }

    // Drawing functions
    function drawPlayer() {
      const angle = Math.atan2(mousePos.y - player.y, mousePos.x - player.x) - Math.PI/2;
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(angle);
      ctx.shadowColor = player.color;
      ctx.shadowBlur = 50;
      ctx.drawImage(playerImage, -player.size/2, -player.size/2, player.size, player.size);
      ctx.restore();
    }
    function drawOtherPlayers() {
      for (const id in otherPlayers) {
        if (id === socket.id) continue;
        const op = otherPlayers[id];
        ctx.save();
        ctx.translate(op.x, op.y);
        ctx.drawImage(playerImage, - (op.size || 40) / 2, - (op.size || 40) / 2, op.size || 40, op.size || 40);
        ctx.restore();
      }
    }
    function drawShield() {
      if (shieldActive) {
        const shieldRadius = player.size / 2 + 17;
        ctx.beginPath();
        ctx.arc(player.x, player.y, shieldRadius, 0, Math.PI * 2);
        ctx.strokeStyle = getShieldColor();
        ctx.lineWidth = 10;
        ctx.shadowColor = getShieldColor();
        ctx.shadowBlur = 20;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }
    function getShieldColor() {
      if (shieldDurability === 3) return "#00FFFF";
      else if (shieldDurability === 2) return "yellow";
      else if (shieldDurability === 1) return "red";
      else return "#00FFFF";
    }
    function updateBullets() {
      // Update player's bullets
      for (let i = player.bullets.length - 1; i >= 0; i--) {
        const bullet = player.bullets[i];
        if (bullet.lifetime && performance.now() - bullet.creationTime >= bullet.lifetime) {
          player.bullets.splice(i, 1);
          continue;
        }
        bullet.x += bullet.dx;
        bullet.y += bullet.dy;
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
          player.bullets.splice(i, 1);
        }
      }
      // Update other bullets (from remote players)
      for (let i = otherBullets.length - 1; i >= 0; i--) {
        const bullet = otherBullets[i];
        bullet.x += bullet.dx;
        bullet.y += bullet.dy;
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height ||
            performance.now() - bullet.creationTime > bullet.lifetime) {
          otherBullets.splice(i, 1);
        }
      }
      // Bullet collision between player's bullets and remote bullets
      for (let i = player.bullets.length - 1; i >= 0; i--) {
        for (let j = otherBullets.length - 1; j >= 0; j--) {
          if (checkBulletCollision(player.bullets[i], otherBullets[j])) {
            player.bullets.splice(i, 1);
            otherBullets.splice(j, 1);
            break;
          }
        }
      }
      // Remote bullet hitting player
      for (let i = otherBullets.length - 1; i >= 0; i--) {
        if (checkCollision(otherBullets[i], player)) {
          otherBullets.splice(i, 1);
          socket.emit("playerHit", { id: socket.id, damage: 10 });
          player.health -= 10;
          if (player.health <= 0) {
            document.getElementById("gameOverScreen").style.display = "flex";
            cancelAnimationFrame(gameLoopId);
          }
        }
      }
      // Player bullet hitting remote players
      for (const id in otherPlayers) {
        const remotePlayer = otherPlayers[id];
        for (let i = player.bullets.length - 1; i >= 0; i--) {
          if (checkCollision(player.bullets[i], remotePlayer)) {
            player.bullets.splice(i, 1);
            socket.emit("playerHit", { targetId: remotePlayer.id, damage: 10 });
            remotePlayer.health = (remotePlayer.health || 100) - 10;
          }
        }
      }
      // Update enemy bullets
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const bullet = enemyBullets[i];
        bullet.x += bullet.dx;
        bullet.y += bullet.dy;
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
          enemyBullets.splice(i, 1);
        }
      }
      // Update boss enemy bullets
      enemies.forEach(enemy => {
        if (enemy.type === "boss") {
          for (let i = enemy.bullets.length - 1; i >= 0; i--) {
            const bullet = enemy.bullets[i];
            bullet.x += bullet.dx;
            bullet.y += bullet.dy;
            if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
              enemy.bullets.splice(i, 1);
            }
          }
        }
      });
    }
    function checkBulletCollision(b1, b2) {
      const dx = b1.x - b2.x, dy = b1.y - b2.y;
      return Math.sqrt(dx*dx + dy*dy) < (b1.size + b2.size);
    }
    function checkCollision(obj1, obj2) {
      const dx = obj1.x - obj2.x, dy = obj1.y - obj2.y;
      const r1 = (obj1.size || 40) / 2, r2 = (obj2.size || 40) / 2;
      return Math.sqrt(dx*dx + dy*dy) < (r1 + r2);
    }
    function drawHealthBoosts() {
      healthBoosts.forEach(boost => {
        ctx.shadowColor = "green";
        ctx.shadowBlur = 5;
        ctx.fillStyle = boost.color;
        ctx.beginPath();
        ctx.arc(boost.x, boost.y, boost.size, 0, Math.PI*2);
        ctx.fill();
      });
    }
    function drawCoins() {
      coinsOnField.forEach(coin => {
        ctx.shadowColor = "gold";
        ctx.shadowBlur = 5;
        ctx.fillStyle = coin.color;
        ctx.beginPath();
        ctx.arc(coin.x, coin.y, coin.size, 0, Math.PI*2);
        ctx.fill();
      });
    }
    function drawBullets() {
      player.bullets.forEach(bullet => {
        if (bullet.flamethrower) {
          ctx.shadowColor = "red";
          ctx.shadowBlur = 8;
          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, 10, 0, Math.PI*2);
          ctx.fill();
        } else {
          ctx.shadowColor = "red";
          ctx.shadowBlur = 8;
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI*2);
          ctx.fill();
        }
      });
      player.bullets.forEach(bullet => {
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI*2);
        ctx.fill();
      });
      otherBullets.forEach(bullet => {
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI*2);
        ctx.fill();
      });
      enemyBullets.forEach(bullet => {
        ctx.shadowColor = "darkblue";
        ctx.shadowBlur = 8;
        ctx.fillStyle = "darkblue";
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI*2);
        ctx.fill();
      });
    }
    function updatePlayer() {
      const speed = 4;
      if (keys["w"] && player.y - player.size/2 > 0) player.y -= speed;
      if (keys["s"] && player.y + player.size/2 < canvas.height) player.y += speed;
      if (keys["a"] && player.x - player.size/2 > 0) player.x -= speed;
      if (keys["d"] && player.x + player.size/2 < canvas.width) player.x += speed;
      socket.emit('playerMove', { x: player.x, y: player.y });
    }
    function normalizeAngle(angle) {
      while(angle > Math.PI) angle -= 2*Math.PI;
      while(angle < -Math.PI) angle += 2*Math.PI;
      return angle;
    }
    function isInShieldZone(x, y) {
      const angleToPoint = Math.atan2(y - player.y, x - player.x);
      const shieldAngle = Math.atan2(mousePos.y - player.y, mousePos.x - player.x) - Math.PI/2;
      return Math.abs(normalizeAngle(angleToPoint - shieldAngle)) < 0.785;
    }
    function updateEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.type === "clone") {
          if (enemy.isSplitting) {
            enemy.x += enemy.dx;
            enemy.y += enemy.dy;
            if (performance.now() >= enemy.splitTime) {
              enemy.isSplitting = false;
              enemy.dx = 0;
              enemy.dy = 0;
            }
          } else {
            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            enemy.x += Math.cos(angle) * enemy.speed;
            enemy.y += Math.sin(angle) * enemy.speed;
          }
        } else {
          const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
          enemy.x += Math.cos(angle) * enemy.speed;
          enemy.y += Math.sin(angle) * enemy.speed;
        }
        if (
          player.x + player.size/2 > enemy.x - enemy.size/2 &&
          player.x - player.size/2 < enemy.x + enemy.size/2 &&
          player.y + player.size/2 > enemy.y - enemy.size/2 &&
          player.y - player.size/2 < enemy.y + enemy.size/2
        ) {
          if (shieldActive) {
            shieldHit();
            if (enemy.shootInterval) clearInterval(enemy.shootInterval);
            enemies.splice(i, 1);
          } else {
            if (enemy.type === "boss") health = 0;
            health -= 30;
            if (enemy.shootInterval) clearInterval(enemy.shootInterval);
            enemies.splice(i, 1);
            if (health <= 0) { endGame(); return; }
          }
        }
      }
    }
    function shootAtPlayer(enemy) {
      const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
      const bullet = {
        x: enemy.x,
        y: enemy.y,
        dx: Math.cos(angle) * 5,
        dy: Math.sin(angle) * 5,
        size: 5,
        color: enemy.type === "boss" ? "purple" : "darkblue"
      };
      if (enemy.type === "shooter") enemyBullets.push(bullet);
      else enemy.bullets.push(bullet);
    }
    function bossShoot(enemy) {
      const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
      const aimedBullet = {
        x: enemy.x,
        y: enemy.y,
        dx: Math.cos(angle) * 6,
        dy: Math.sin(angle) * 6,
        size: 10,
        color: "purple"
      };
      enemy.bullets.push(aimedBullet);
      const bulletCount = 12, bulletSpeed = 4;
      for (let i = 0; i < bulletCount; i++) {
        const ringAngle = (2 * Math.PI * i) / bulletCount;
        enemy.bullets.push({
          x: enemy.x,
          y: enemy.y,
          dx: Math.cos(ringAngle) * bulletSpeed,
          dy: Math.sin(ringAngle) * bulletSpeed,
          size: 5,
          color: "purple"
        });
      }
    }
    function initBoss(enemy) {
      enemy.aimedShootInterval = setInterval(() => {
        if (enemies.includes(enemy)) {
          const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
          enemy.bullets.push({
            x: enemy.x,
            y: enemy.y,
            dx: Math.cos(angle) * 5,
            dy: Math.sin(angle) * 5,
            size: 5,
            color: "purple"
          });
        } else clearInterval(enemy.aimedShootInterval);
      }, 1500);
      enemy.ringShootInterval = setInterval(() => {
        if (enemies.includes(enemy)) {
          const bulletCount = 12, bulletSpeed = 4;
          for (let i = 0; i < bulletCount; i++) {
            const ringAngle = (2 * Math.PI * i) / bulletCount;
            enemy.bullets.push({
              x: enemy.x,
              y: enemy.y,
              dx: Math.cos(ringAngle) * bulletSpeed,
              dy: Math.sin(ringAngle) * bulletSpeed,
              size: 5,
              color: "purple"
            });
          }
        } else clearInterval(enemy.ringShootInterval);
      }, 3000);
    }
    function checkBulletCollisions() {
      for (let i = player.bullets.length - 1; i >= 0; i--) {
        const bullet = player.bullets[i];
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          if (
            bullet.x >= enemy.x - enemy.size/2 &&
            bullet.x <= enemy.x + enemy.size/2 &&
            bullet.y >= enemy.y - enemy.size/2 &&
            bullet.y <= enemy.y + enemy.size/2
          ) {
            if (enemy.type === "tank") {
              enemy.hitsRemaining--;
              player.bullets.splice(i, 1);
              if (enemy.hitsRemaining <= 0) {
                score += 15;
                health = Math.min(100, health + 5);
                enemies.splice(j, 1);
                playEnemyKillSound();
              }
              break;
            } else if (enemy.type === "shooter") {
              enemy.hitsRemaining--;
              player.bullets.splice(i, 1);
              if (enemy.hitsRemaining <= 0) {
                score += 10;
                enemies.splice(j, 1);
                playEnemyKillSound();
              }
            } else if (enemy.type === "boss") {
              enemy.hitsRemaining--;
              player.bullets.splice(i, 1);
              if (enemy.hitsRemaining <= 0) {
                score += 50;
                clearInterval(enemy.shootInterval);
                enemyBullets.push(...enemy.bullets);
                enemy.bullets = [];
                enemies.splice(j, 1);
              }
              break;
            } else if (enemy.type === "clone") {
              if (enemy.canClone) {
                const baseAngle = Math.random() * 2 * Math.PI;
                const splitSpeed = 5, currentTime = performance.now();
                const clone1 = {
                  x: enemy.x,
                  y: enemy.y,
                  type: "clone",
                  size: enemy.size / 2,
                  color: "white",
                  speed: enemy.speed,
                  canClone: false,
                  isSplitting: true,
                  splitTime: currentTime + 500,
                  dx: Math.cos(baseAngle + 0.3) * splitSpeed,
                  dy: Math.sin(baseAngle + 0.3) * splitSpeed
                };
                const clone2 = {
                  x: enemy.x,
                  y: enemy.y,
                  type: "clone",
                  size: enemy.size / 2,
                  color: "white",
                  speed: enemy.speed,
                  canClone: false,
                  isSplitting: true,
                  splitTime: currentTime + 500,
                  dx: Math.cos(baseAngle - 0.3) * splitSpeed,
                  dy: Math.sin(baseAngle - 0.3) * splitSpeed
                };
                enemies.splice(j, 1);
                enemies.push(clone1, clone2);
                score += 15;
                health = Math.min(100, health + 5);
                player.bullets.splice(i, 1);
                playEnemyKillSound();
                break;
              } else {
                score += 15;
                health = Math.min(100, health + 5);
                player.bullets.splice(i, 1);
                enemies.splice(j, 1);
                playEnemyKillSound();
                break;
              }
            } else {
              score += 15;
              health = Math.min(100, health + 5);
              player.bullets.splice(i, 1);
              enemies.splice(j, 1);
              playEnemyKillSound();
              break;
            }
          }
        }
      }
      enemyBullets.forEach((bullet, i) => {
        if (Math.hypot(bullet.x - player.x, bullet.y - player.y) < player.size/2 + bullet.size) {
          if (isInShieldZone(bullet.x, bullet.y) && shieldActive) {
            shieldHit();
            enemyBullets.splice(i, 1);
          } else {
            health -= health * 0.25;
            enemyBullets.splice(i, 1);
            if (health <= 0) endGame();
          }
        }
      });
      enemies.forEach(enemy => {
        if (enemy.type === "boss") {
          enemy.bullets.forEach((bullet, i) => {
            if (Math.hypot(bullet.x - player.x, bullet.y - player.y) < player.size/2 + bullet.size) {
              if (isInShieldZone(bullet.x, bullet.y) && shieldActive) {
                shieldHit();
                enemy.bullets.splice(i, 1);
              } else {
                health -= health * 0.25;
                enemy.bullets.splice(i, 1);
                if (health <= 0) endGame();
              }
            }
          });
        }
      });
    }
    function checkHealthBoostCollisions() {
      for (let i = healthBoosts.length - 1; i >= 0; i--) {
        const boost = healthBoosts[i];
        if (Math.hypot(player.x - boost.x, player.y - boost.y) < (player.size + boost.size) / 2) {
          health = Math.min(100, health + 20);
          healthBoosts.splice(i, 1);
        }
      }
    }
    function checkCoinCollisions() {
      for (let i = coinsOnField.length - 1; i >= 0; i--) {
        const coin = coinsOnField[i];
        if (Math.hypot(player.x - coin.x, player.y - coin.y) < (player.size + coin.size) / 2) {
          coinCount++;
          localStorage.setItem("coinCount", coinCount);
          updateCoinCounters();
          coinsOnField.splice(i, 1);
        }
      }
    }
    function updateHealthBar() {
      const inner = document.getElementById("healthBarInner");
      inner.style.width = `${health}%`;
      inner.style.backgroundColor = health > 50 ? "green" : "orange";
    }
    function shieldHit() {
      shieldDurability--;
      if (shieldDurability <= 0) {
        shieldActive = false;
        startShieldCooldown();
      }
    }
    function startShieldCooldown() {
      shieldCooldownActive = true;
      shieldCooldownStart = performance.now();
      document.getElementById("shieldCooldownBox").style.display = "block";
    }
    function checkHealth() {
      if (health <= 0) {
        endGame();
        socket.emit('playerDied');
      }
    }
    function showRespawnTimer(timeLeft) {
      document.getElementById("respawnTimer").textContent = `Respawning in ${timeLeft} seconds`;
    }
    function endGame() {
      if (gameMode === "challenge") {
        challengeTimerActive = false;
        document.getElementById("challengeTimer").style.display = "none";
      }
      document.getElementById("gameOverScreen").style.display = "flex";
      document.getElementById("respawnTimer").style.display = "block";
      document.getElementById("finalScore").textContent = `Final Score: ${score}`;
      updateLeaderboard(score);
      let respawnTime = 5;
      const interval = setInterval(() => {
        showRespawnTimer(respawnTime);
        respawnTime--;
        if (respawnTime < 0) {
          clearInterval(interval);
          socket.emit('playerRespawn');
        }
      }, 1000);
    }
    function handleWaveLogic(timestamp) {
      if (gameMode !== "zombies") return;
      if (welcomePhase) {
        if (timestamp >= welcomePhaseEndTime) {
          welcomePhase = false;
          nextWaveTime = timestamp;
          waveStarted = false;
          enemiesSpawnedForWave = false;
        } else {
          document.getElementById("roundMessage").textContent = "Welcome Agent B-XFTR";
          document.getElementById("roundMessage").style.opacity = 1;
          return;
        }
      }
      if (timestamp >= nextWaveTime) {
        if (!waveStarted) {
          waveStartTime = timestamp;
          document.getElementById("roundMessage").textContent = roundNumber === 5 ? "Boss Incoming" : "Wave " + roundNumber;
          document.getElementById("roundMessage").style.opacity = 1;
          waveStarted = true;
        }
        if (timestamp >= waveStartTime + waveMessageDuration && !enemiesSpawnedForWave) {
          if (roundNumber === 5) {
            const bossEnemy = {
              x: canvas.width / 2,
              y: canvas.height / 4,
              type: "boss",
              size: 120,
              color: "darkred",
              speed: 2.35,
              hitsRemaining: 85,
              bullets: []
            };
            initBoss(bossEnemy);
            enemies.push(bossEnemy);
          } else {
            spawnEnemies();
            spawnHealthBoost();
            spawnCoin();
            if (roundNumber > 10 && Math.random() < 0.3) {
              const extraBoss = {
                x: canvas.width / 2,
                y: canvas.height / 4,
                type: "boss",
                size: 120,
                color: "darkred",
                speed: 2.35,
                hitsRemaining: 85,
                bullets: []
              };
              initBoss(extraBoss);
              enemies.push(extraBoss);
            }
          }
          enemiesSpawnedForWave = true;
          document.getElementById("roundMessage").style.opacity = 0;
        }
        if (timestamp >= nextWaveTime + waveInterval) {
          roundNumber++;
          nextWaveTime = timestamp;
          waveStarted = false;
          enemiesSpawnedForWave = false;
        }
      }
    }
    function handleChallengeMode(timestamp) {
      if (!challengeTimerActive) return;
      if (health <= 0) { challengeTimerActive = false; return; }
      const elapsed = timestamp - challengeStartTime;
      if (elapsed >= 300000) {
        enemies = [];
        enemyBullets = [];
        document.getElementById("roundMessage").textContent = "You Win!";
        document.getElementById("roundMessage").style.opacity = 1;
        challengeTimerActive = false;
        setTimeout(endChallengeMode, 10000);
      } else {
        if (timestamp - lastChallengeSpawnTime >= 1000) {
          spawnSingleEnemy();
          lastChallengeSpawnTime = timestamp;
        }
        const remaining = 300000 - elapsed;
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        document.getElementById("challengeTimer").textContent = `Time Left: ${minutes}:${seconds < 10 ? "0" + seconds : seconds}`;
      }
    }
    function spawnSingleEnemy() {
      const types = ["melee", "shooter", "tank", "clone", "boss"];
      const type = types[Math.floor(Math.random() * types.length)];
      const pos = getRandomSpawnPosition(100);
      const enemy = { x: pos.x, y: pos.y, type, dx: 0, dy: 0, bullets: [] };
      if (type === "shooter") {
        enemy.size = 40;
        enemy.color = "darkblue";
        enemy.speed = 1.75;
        enemy.hitsRemaining = 2;
        enemy.shootInterval = setInterval(() => {
          if (enemies.includes(enemy)) shootAtPlayer(enemy);
          else clearInterval(enemy.shootInterval);
        }, 800);
      } else if (type === "tank") {
        enemy.size = 60;
        enemy.color = "yellow";
        enemy.speed = 1.25;
        enemy.hitsRemaining = 5;
      } else if (type === "clone") {
        enemy.size = 30;
        enemy.color = "white";
        enemy.speed = 2.35;
        enemy.canClone = true;
        enemy.isSplitting = false;
      } else if (type === "boss") {
        enemy.size = 120;
        enemy.color = "darkred";
        enemy.speed = 2.35;
        enemy.hitsRemaining = 85;
        initBoss(enemy);
      } else {
        enemy.size = 30;
        enemy.color = "red";
        enemy.speed = 2.35;
      }
      enemies.push(enemy);
    }
    function endChallengeMode() {
      pauseGame();
      document.getElementById("roundMessage").style.opacity = 0;
      challengeTimerActive = false;
    }
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (shieldCooldownActive) {
        const elapsed = (performance.now() - shieldCooldownStart) / 1000;
        const remaining = Math.max(0, 10 - elapsed);
        const cooldownBox = document.getElementById("shieldCooldownBox");
        cooldownBox.textContent = `Shield Cooldown: ${remaining.toFixed(1)}s`;
        if (remaining <= 0) {
          shieldCooldownActive = false;
          cooldownBox.style.display = "none";
        }
      }
      if (gameMode === "challenge" && !paused) {
        handleChallengeMode(timestamp);
      } else {
        handleWaveLogic(timestamp);
      }
      updatePlayer();
      updateBullets();
      updateEnemies();
      checkBulletCollisions();
      checkHealthBoostCollisions();
      checkCoinCollisions();
      updateHealthBar();
      updateBossHealthBars();
      drawPlayer();
      drawShield();
      // (Assuming you have a drawEnemies() function if needed)
      drawBullets();
      drawHealthBoosts();
      drawCoins();
      drawOtherPlayers();
      document.getElementById("score").textContent = `Score: ${score}`;
      gameLoopId = requestAnimationFrame(gameLoop);
    }

    /* ========= Input & Event Listeners ========= */
    window.addEventListener("keydown", (e) => { keys[e.key] = true; });
    window.addEventListener("keyup", (e) => { keys[e.key] = false; });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") pauseGame();
      if (e.code === "Space" && shieldEquipped && !shieldActive && !shieldCooldownActive) {
        activateShield();
      }
    });
    function activateShield() {
      shieldActive = true;
      shieldDurability = 3;
    }

    let flamethrowerInterval = null;
    let lastMousePos = { x: player.x, y: player.y };
    canvas.addEventListener("click", (e) => {
      if (playerGun !== "flamethrower") {
        playShootSound();
        const angle = Math.atan2(e.clientY - player.y, e.clientX - player.x);
        if (playerGun === "shotgun") {
          const spread = 0.2;
          player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle) * 6.5, dy: Math.sin(angle) * 6.5 });
          player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle - spread) * 6.5, dy: Math.sin(angle - spread) * 6.5 });
          player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle + spread) * 6.5, dy: Math.sin(angle + spread) * 6.5 });
        } else if (playerGun === "uzi") {
          for (let i = 0; i < 5; i++) {
            setTimeout(() => {
              const deviation = (Math.random() - 0.5) * 0.2;
              const bulletAngle = angle + deviation;
              player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(bulletAngle) * 6.5, dy: Math.sin(bulletAngle) * 6.5 });
            }, i * 50);
          }
        } else {
          player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle) * 6.5, dy: Math.sin(angle) * 6.5 });
        }
      }
    });
    canvas.addEventListener("mousedown", (e) => {
      if (playerGun === "flamethrower") {
        lastMousePos = { x: e.clientX, y: e.clientY };
        if (!flamethrowerInterval) flamethrowerInterval = setInterval(shootFlame, 100);
      }
    });
    canvas.addEventListener("mouseup", () => {
      if (playerGun === "flamethrower" && flamethrowerInterval) {
        clearInterval(flamethrowerInterval);
        flamethrowerInterval = null;
      }
    });
    canvas.addEventListener("mousemove", (e) => {
      if (playerGun === "flamethrower") lastMousePos = { x: e.clientX, y: e.clientY };
    });
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      if (playerGun === "flamethrower") {
        const touch = e.changedTouches[0];
        lastMousePos = { x: touch.clientX, y: touch.clientY };
        if (!flamethrowerInterval) flamethrowerInterval = setInterval(shootFlame, 100);
      } else {
        playShootSound();
        for (const touch of e.changedTouches) {
          const angle = Math.atan2(touch.clientY - player.y, touch.clientX - player.x);
          if (playerGun === "shotgun") {
            const spread = 0.2;
            player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle) * 6.5, dy: Math.sin(angle) * 6.5 });
            player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle - spread) * 6.5, dy: Math.sin(angle - spread) * 6.5 });
            player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle + spread) * 6.5, dy: Math.sin(angle + spread) * 6.5 });
          } else if (playerGun === "uzi") {
            for (let i = 0; i < 5; i++) {
              setTimeout(() => {
                const deviation = (Math.random() - 0.5) * 0.2;
                const bulletAngle = angle + deviation;
                player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(bulletAngle) * 6.5, dy: Math.sin(bulletAngle) * 6.5 });
              }, i * 100);
            }
          } else {
            player.bullets.push({ x: player.x, y: player.y, dx: Math.cos(angle) * 6.5, dy: Math.sin(angle) * 6.5 });
          }
        }
      }
    }, { passive: false });
    canvas.addEventListener("touchend", () => {
      if (playerGun === "flamethrower" && flamethrowerInterval) {
        clearInterval(flamethrowerInterval);
        flamethrowerInterval = null;
      }
    });
    canvas.addEventListener("touchmove", (e) => {
      if (playerGun === "flamethrower") {
        const touch = e.touches[0];
        lastMousePos = { x: touch.clientX, y: touch.clientY };
      }
    });
    function shootFlame() {
      const baseAngle = Math.atan2(lastMousePos.y - player.y, lastMousePos.x - player.x) || 0;
      const spread = 0.2, speed = 4;
      for (let i = -2; i <= 2; i++) {
        const bulletAngle = baseAngle + i * spread;
        player.bullets.push({
          x: player.x,
          y: player.y,
          dx: Math.cos(bulletAngle) * speed,
          dy: Math.sin(bulletAngle) * speed,
          lifetime: 500,
          creationTime: performance.now(),
          flamethrower: true
        });
      }
    }
    function spawnEnemies() {
      const numberOfEnemies = 8 + roundNumber - 1;
      for (let i = 0; i < numberOfEnemies; i++) {
        const r = Math.random();
        let type;
        if (roundNumber >= 5 && r > 0.8) type = "clone";
        else if (r < 0.15) type = "tank";
        else if (r < 0.4) type = "shooter";
        else type = "melee";
        const enemy = {
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          type,
          dx: 0,
          dy: 0,
          bullets: []
        };
        if (type === "shooter") {
          enemy.size = 40;
          enemy.color = "darkblue";
          enemy.speed = 1.75;
          enemy.hitsRemaining = 2;
          enemy.shootInterval = setInterval(() => {
            if (enemies.includes(enemy)) shootAtPlayer(enemy);
            else clearInterval(enemy.shootInterval);
          }, 800);
        } else if (type === "tank") {
          enemy.size = 60;
          enemy.color = "yellow";
          enemy.speed = 1.25;
          enemy.hitsRemaining = 5;
        } else if (type === "clone") {
          enemy.size = 30;
          enemy.color = "white";
          enemy.speed = 2.35;
          enemy.canClone = true;
          enemy.isSplitting = false;
        } else {
          enemy.size = 30;
          enemy.color = "red";
          enemy.speed = 2.35;
        }
        enemies.push(enemy);
      }
    }
    function updateLeaderboard(score) {
      leaderboard.push(score);
      leaderboard.sort((a, b) => b - a);
      leaderboard = leaderboard.slice(0, 5);
      localStorage.setItem("leaderboard", JSON.stringify(leaderboard));
      displayLeaderboard();
    }
    function toggleMusic() {
      const bgMusic = document.getElementById("bgMusic");
      const muteButton = document.getElementById("muteButton");
      if (bgMusic.muted) {
        bgMusic.muted = false;
        muteButton.textContent = "Mute Music";
      } else {
        bgMusic.muted = true;
        muteButton.textContent = "Unmute Music";
      }
    }
    function openGunShop() { document.getElementById("gunShopModal").style.display = "block"; }
    function closeGunShop() { document.getElementById("gunShopModal").style.display = "none"; }
    function selectGun(gun) {
      if (gun === "rifle") {
        playerGun = "rifle";
        shieldEquipped = false;
        alert("Rifle equipped!");
      } else if (gun === "shield") {
        if (ownedGuns.includes("shield")) {
          shieldEquipped = true;
          alert("Shield equipped! (Press Space to deploy)");
        } else {
          if (coinCount * 50 >= 5000) {
            coinCount -= 100;
            localStorage.setItem("coinCount", coinCount);
            updateCoinCounters();
            shieldEquipped = true;
            ownedGuns.push("shield");
            localStorage.setItem("ownedGuns", JSON.stringify(ownedGuns));
            alert("Shield purchased and equipped! (Press Space to deploy)");
          } else {
            alert("Not enough coins for Shield!");
          }
        }
      } else {
        if (ownedGuns.includes(gun)) {
          playerGun = gun;
          shieldEquipped = false;
          alert(gun.charAt(0).toUpperCase() + gun.slice(1) + " equipped!");
        } else {
          if (gun === "shotgun") {
            if (coinCount * 50 >= 300) {
              coinCount -= 6;
              localStorage.setItem("coinCount", coinCount);
              updateCoinCounters();
              playerGun = "shotgun";
              shieldEquipped = false;
              ownedGuns.push("shotgun");
              localStorage.setItem("ownedGuns", JSON.stringify(ownedGuns));
              alert("Shotgun purchased and equipped!");
            } else { alert("Not enough coins for Shotgun!"); }
          } else if (gun === "flamethrower") {
            if (coinCount * 50 >= 1000) {
              coinCount -= 20;
              localStorage.setItem("coinCount", coinCount);
              updateCoinCounters();
              playerGun = "flamethrower";
              shieldEquipped = false;
              ownedGuns.push("flamethrower");
              localStorage.setItem("ownedGuns", JSON.stringify(ownedGuns));
              alert("Flamethrower purchased and equipped!");
            } else { alert("Not enough coins for Flamethrower!"); }
          } else if (gun === "uzi") {
            if (coinCount * 50 >= 2000) {
              coinCount -= 40;
              localStorage.setItem("coinCount", coinCount);
              updateCoinCounters();
              playerGun = "uzi";
              shieldEquipped = false;
              ownedGuns.push("uzi");
              localStorage.setItem("ownedGuns", JSON.stringify(ownedGuns));
              alert("Uzi purchased and equipped!");
            } else { alert("Not enough coins for Uzi!"); }
          }
        }
      }
      closeGunShop();
    }
    function openGameModeBox() { document.getElementById("gameModeModal").style.display = "block"; }
    function closeGameMode() { document.getElementById("gameModeModal").style.display = "none"; }
    function selectGameMode(mode) {
      gameMode = mode;
      enemies = [];
      enemyBullets = [];
      healthBoosts = [];
      coinsOnField = [];
      if (gameMode === "zombies") {
        challengeStartTime = 0;
        lastChallengeSpawnTime = 0;
        challengeTimerActive = false;
        roundNumber = 1;
        nextWaveTime = performance.now();
        welcomePhase = true;
        welcomePhaseEndTime = performance.now() + 5000;
        document.getElementById("roundMessage").textContent = "Welcome Agent B-XFTR";
        document.getElementById("roundMessage").style.opacity = 1;
      } else if (gameMode === "challenge") {
        document.getElementById("roundMessage").style.opacity = 0;
        challengeStartTime = performance.now();
        lastChallengeSpawnTime = performance.now();
        challengeTimerActive = true;
      } else if (gameMode === "pvp") {
        document.getElementById("roundMessage").textContent = "PVP Mode: Waiting for opponent...";
        document.getElementById("roundMessage").style.opacity = 1;
      }
      if (gameStarted) pauseGame();
      closeGameMode();
      alert("Game mode switched to " + (mode === "zombies" ? "Zombies" : mode === "challenge" ? "Challenge Mode" : "PVP") + ". Ready up to start.");
    }
  </script>
</body>
</html>
