<!DOCTYPE html>
<html lang="en">
<head>
  <script src="https://cdn.socket.io/4.5.1/socket.io.min.js"></script>

  <link rel="icon" type="image/png" href="favicon.ico">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Box Fighter</title>
  <!-- Importing a modern, appealing font -->
  <link href="https://fonts.googleapis.com/css?family=Poppins:400,600&display=swap" rel="stylesheet">
  <style>
    body,
    html {
      margin: 0;
      overflow: hidden;
      font-family: 'Poppins', sans-serif;
      height: 100%;
      background-color: #1e1e1e;
    }
    /* Main Menu Styling */
    #startMenu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      z-index: 100;
      user-select: none;
    }
    /* Studios text styling */
    #studiosText {
      font-size: 24px;
      background: linear-gradient(45deg, #ff6b6b, #ffcd3c, #6b94ff, #6bffb8);
      -webkit-background-clip: text;
      color: transparent;
      animation: gradient-text 4s linear infinite;
      margin-bottom: 20px;
    }
    /* Coin counter for main menu (top right) */
    #menuCoinCounter {
      position: absolute;
      top: 50px;
      right: 5px;
      border: 2px solid gold;
      padding: 6px 6px;
      border-radius: 10px;
      font-size: 17px;
      background: rgba(0, 0, 0, 0.5);
      color: gold;
      z-index: 110;
    }
    /* Gun Shop Button (Main Menu) */
    #menuGunShopButton {
      font-size: 20px;
      padding: 10px 20px;
      background-color: #344;
      border: 2px solid white;
      color: white;
      cursor: pointer;
      border-radius: 50px;
      transition: transform 0.5s ease, background-color 0.5s ease;
      margin-top: 15px;
    }
    #menuGunShopButton:hover {
      background-color: #ff6b6b;
      transform: scale(1.2);
    }
    #menuGunShopButton:active {
      transform: scale(1.05);
    }
    /* Game Mode Button (Main Menu) */
    #gameModeButton {
      font-size: 20px;
      padding: 10px 20px;
      background-color: #344;
      border: 2px solid white;
      color: white;
      cursor: pointer;
      border-radius: 50px;
      transition: transform 0.5s ease, background-color 0.5s ease;
      margin-top: 15px;
    }
    #gameModeButton:hover {
      background-color: #ff6b6b;
      transform: scale(1.2);
    }
    #gameModeButton:active {
      transform: scale(1.05);
    }
    /* Animated Title (Box Fighter) */
    h1 {
      font-size: 80px;
      text-align: center;
      background: linear-gradient(45deg, #ff6b6b, #ffcd3c, #6b94ff, #6bffb8);
      -webkit-background-clip: text;
      color: transparent;
      animation: gradient-text 3s linear infinite, pulsate 2s ease-in-out infinite;
      margin-bottom: 30px;
    }
    @keyframes pulsate {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    @keyframes gradient-text {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    /* Button Styling */
    button {
      font-size: 24px;
      padding: 15px 30px;
      background-color: #344;
      border: none;
      color: white;
      cursor: pointer;
      border-radius: 10px;
      transition: transform 0.5s ease, background-color 0.5s ease;
      margin-top: 20px;
    }
    button:hover {
      background-color: #ff6b6b;
      transform: scale(1.2);
    }
    button:active {
      transform: scale(1.05);
    }
    /* Mute Music Button - Fixed in Top Right */
    #muteButton {
      position: fixed;
      top: -15px;
      right: 5px;
      z-index: 110;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #222;
      border: 2px solid #fff;
      border-radius: 5px;
      user-select: none;
    }
    /* Game UI (Hidden by default) */
    #gameUI {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      z-index: 10;
    }
    #healthBar {
      width: 250px;
      height: 30px;
      border: 3px solid white;
      margin-bottom: 10px;
      border-radius: 5px;
    }
    #healthBarInner {
      height: 100%;
      background-color: green;
      transition: width 0.3s;
    }
    /* Boss Health Bars Container */
    #bossHealthBarContainer {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      z-index: 15;
      display: none;
    }
    .bossHealthBar {
      height: 30px;
      background-color: darkred;
      border: 3px solid white;
      border-radius: 20px;
      margin: 5px 0;
      transition: width 0.3s;
    }
    /* Canvas: Updated to use a full-screen background image */
    canvas {
      display: block;
      background: url('https://i.postimg.cc/C1dhpGkh/1348017.png') no-repeat center center fixed;
      background-size: cover;
      touch-action: none;
    }
    /* Game Over Screen Styling */
    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      flex-direction: column;
      z-index: 100;
      display: none;
      user-select: none;
    }
    /* Gun Shop Button for Game Over Screen */
    #gameOverGunShopButton {
      font-size: 20px;
      padding: 10px 20px;
      background-color: #344;
      border: 2px solid white;
      color: white;
      cursor: pointer;
      border-radius: 50px;
      transition: transform 0.5s ease, background-color 0.5s ease;
      margin-top: 15px;
    }
    #gameOverGunShopButton:hover {
      background-color: #ff6b6b;
      transform: scale(1.2);
    }
    #gameOverGunShopButton:active {
      transform: scale(1.05);
    }
    /* Coin Counter for Game Over Screen */
    #gameOverCoinCounter {
      border: 2px solid gold;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 25px;
      background: rgba(0, 0, 0, 0.5);
      color: gold;
      margin: 10px 0;
    }
    #colorPickerContainer {
      margin: 20px 0;
      text-align: center;
    }
    #colorPickerContainer label {
      color: silver;
      margin-right: 20px;
    }
    /* The preview now shows the player ship with drop-shadow */
    #colorPreview {
      width: 40px;
      height: 40px;
      margin: 10px auto;
    }
    #leaderboard {
      background-color: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      max-height: 200px;
      overflow-y: auto;
    }
    #leaderboard h2 {
      margin: 0 0 10px 0;
      color: #ff6b6b;
    }
    #leaderboardList {
      list-style: none;
      padding: 0;
      margin: 0;
      user-select: none;
    }
    #leaderboardList li {
      color: white;
      font-size: 18px;
      padding: 5px 10px;
      margin: 5px 0;
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 5px;
      user-select: none;
    }
    /* Updated Welcome / Wave / Boss Message Styling */
    #roundMessage {
      position: absolute;
      top: 20%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      font-weight: 600;
      color: black;
      background: white;
      border: 2px solid white;
      border-radius: 15px;
      padding: 10px 20px;
      z-index: 50;
      opacity: 0;
      transition: opacity 2s ease-in-out;
      user-select: none;
    }
    /* Gun Shop Modal Styles */
    #gunShopModal, #gameModeModal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #222;
      border: 3px solid white;
      padding: 20px;
      border-radius: 10px;
      z-index: 200;
      display: none;
      color: white;
      text-align: center;
      width: 300px;
      user-select: none;
    }
    #gunShopModal h2, #gameModeModal h2 {
      margin-top: 0;
    }
    .gunOption, .gameModeOption {
      border: 2px solid white;
      border-radius: 8px;
      padding: 10px;
      margin: 10px 0;
      cursor: pointer;
      transition: background 0.3s ease;
      user-select: none;
    }
    .gunOption:hover, .gameModeOption:hover {
      background: #444;
    }
    #closeGunShop, #closeGameMode {
      margin-top: 15px;
      padding: 5px 10px;
      border: none;
      background: #ff6b6b;
      color: white;
      cursor: pointer;
      border-radius: 5px;
      user-select: none;
    }
    /* Challenge Mode Timer styling */
    #challengeTimer {
      position: absolute;
      top: 70px;
      left: 10px;
      font-size: 20px;
      background: #000000;
      padding: 5px 10px;
      color: white;
      z-index: 20;
      display: none;
      border-radius: 10px;
      user-select: none;
    }
    /* Shield Cooldown Box */
    #shieldCooldownBox {
      position: fixed;
      top: 15%;
      left: 10px;
      transform: translateY(-50%);
      background-color: rgba(0, 0, 0, 0.7);
      color: #00ffff;
      padding: 10px 20px;
      border: 2px solid #00ffff;
      border-radius: 10px;
      font-size: 20px;
      z-index: 120;
      display: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <!-- Background music element -->
  <audio id="bgMusic" src="music.mp3" loop preload="auto"></audio>
  <!-- Enemy kill sound (will be cloned to allow overlapping) -->
  <audio id="enemyKillSound" src="enemy-kill.mp3" preload="auto"></audio>
  <!-- New shoot sound element -->
  <audio id="shootSound" src="shoot.mp3" preload="auto"></audio>
  <!-- Mute Music Button -->
  <button id="muteButton" onclick="toggleMusic()">Mute Music</button>
  <!-- Main Menu Screen -->
  <div id="startMenu">
    <!-- Coin Counter (Main Menu) -->
    <div id="menuCoinCounter">Coins: 0</div>
    <h1>Box Fighter</h1>
    <!-- Studios Text -->
    <div id="studiosText">DanCodeRoman Studios</div>
    <button onclick="startGame()">Ready Up</button>
    <!-- Game Mode Button -->
    <button id="gameModeButton" onclick="openGameModeBox()">Game Mode</button>
    <!-- Gun Shop Button (Main Menu) -->
    <button id="menuGunShopButton" onclick="openGunShop()">Gun Shop</button>
    <div id="colorPickerContainer">
      <label for="playerColor">Choose Agent:</label>
      <input type="color" id="playerColor" value="#39ff14" />
      <div id="colorPreview">
        <img src="player.png" style="width:40px;height:40px;filter: drop-shadow(0 0 10px #39ff14);" />
      </div>
    </div>
  </div>
  <!-- Game Over Screen -->
  <div id="gameOverScreen">
    <h1>Game Over</h1>
    <!-- Coin Counter (Game Over) -->
    <div id="gameOverCoinCounter">Coins: 0</div>
    <p id="finalScore">Final Score: 0</p>
    <div id="leaderboard">
      <h2>Top Scores</h2>
      <ol id="leaderboardList"></ol>
    </div>
    <button onclick="restartGame()">Restart</button>
    <!-- Gun Shop Button (Game Over) -->
    <button id="gameOverGunShopButton" onclick="openGunShop()">Gun Shop</button>
  </div>
  <!-- Gun Shop Modal -->
  <div id="gunShopModal">
    <h2>Gun Shop</h2>
    <div class="gunOption" onclick="selectGun('rifle')">
      <strong>Rifle</strong><br>
      (Free) - Default single shot.
    </div>
    <div class="gunOption" onclick="selectGun('shotgun')">
      <strong>Shotgun</strong><br>
      (300 Coins) - 3-shot spread.
    </div>
    <div class="gunOption" onclick="selectGun('flamethrower')">
      <strong>Flamethrower</strong><br>
      (1000 Coins) - Hold down to continuously shoot a fan of red, short–lived, larger bullets.
    </div>
    <div class="gunOption" onclick="selectGun('uzi')">
      <strong>Uzi</strong><br>
      (2000 Coins) - Burst fire of 5 bullets.
    </div>
    <div class="gunOption" onclick="selectGun('shield')">
      <strong>Shield</strong><br>
      (5000 Coins) - Protects against enemy collisions and bullets.
    </div>
    <button id="closeGunShop" onclick="closeGunShop()">Close</button>
  </div>
  <!-- Game Mode Modal -->
  <div id="gameModeModal">
    <h2>Select Game Mode</h2>
    <div class="gameModeOption" onclick="selectGameMode('zombies')">
      <strong>Zombies</strong>
      <p>Classic waves of enemies with increasing difficulty.</p>
    </div>
    <div class="gameModeOption" onclick="selectGameMode('challenge')">
      <strong>Challenge Mode</strong>
      <p>Survive a continuous enemy onslaught for 5 minutes! New enemies spawn every second.</p>
    </div>
    <div class="gameModeOption" onclick="selectGameMode('pvp')">
      <strong>PVP</strong>
      <p>1v1 Multiplayer battle mode.</p>
    </div>
    <button id="closeGameMode" onclick="closeGameMode()">Close</button>
  </div>
  <div id="gameUI" style="display: none;">
    <div id="healthBar">
      <div id="healthBarInner"></div>
    </div>
    <p id="score" style="user-select: none;">Score: 0</p>
  </div>
  <!-- Challenge Mode Timer -->
  <p id="challengeTimer"></p>
  <!-- Boss Health Bars Container -->
  <div id="bossHealthBarContainer">
    <div class="bossHealthBar" id="bossHealthBar1"></div>
    <div class="bossHealthBar" id="bossHealthBar2" style="display:none;"></div>
  </div>
  <!-- Shield Cooldown Box -->
  <div id="shieldCooldownBox"></div>
  <canvas id="gameCanvas"></canvas>
  <div id="roundMessage"></div>
  
  <script>
    // Set up canvas
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    canvas.addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });

    // Global variables
    let keys = {};
    let health = 100;
    let score = 0;
    let enemies = [];
    let healthBoosts = [];
    let coinsOnField = [];
    let gameLoopId;
    let gameStarted = false;
    let boss = null; // used in rounds < 10

    // Global array for shooter enemy bullets
    let enemyBullets = [];

    // Wave timing variables (for Zombies mode)
    let roundNumber = 1;
    let nextWaveTime = performance.now();
    const waveInterval = 15000;
    const waveMessageDuration = 3000;
    let waveStarted = false;
    let enemiesSpawnedForWave = false;
    let waveStartTime = 0;

    // Welcome phase variables (5 seconds)
    let welcomePhase = true;
    let welcomePhaseEndTime = 0;

    // Challenge Mode variables
    let gameMode = "zombies"; // default game mode
    let challengeStartTime = 0;
    let lastChallengeSpawnTime = 0;
    let challengeTimerActive = false;

    // Global variable for pause time (for Challenge Mode timer)
    let pausedTime = 0;

    // Load owned guns from localStorage; default to ["rifle"]
    let ownedGuns = JSON.parse(localStorage.getItem("ownedGuns")) || ["rifle"];

    // Gun selection: default "rifle"
    let playerGun = "rifle";
    // Shield ability flag
    let shieldEquipped = false;

    // Shield state variables
    let shieldActive = false;
    let shieldDurability = 0;
    let shieldCooldownActive = false;
    let shieldCooldownStart = 0;

    // Global pause state
    let paused = false;

    // Load persistent coin count from localStorage or initialize to 0
    let coinCount = parseInt(localStorage.getItem("coinCount")) || 0;

    // Update coin counter displays
    function updateCoinCounters() {
      const menuCounter = document.getElementById("menuCoinCounter");
      const gameOverCounter = document.getElementById("gameOverCoinCounter");
      menuCounter.textContent = `Coins: ${coinCount * 50}`;
      gameOverCounter.textContent = `Coins: ${coinCount * 50}`;
    }
    updateCoinCounters();

    // Create and load the player ship image.
    const playerImage = new Image();
   playerImage.onload = () => {
  
playerImage.src = 'player.png';  // Set the image source
    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 40,
      color: "#39ff14",
      bullets: []
    };

    // Global mouse position for rotating the ship.
    let mousePos = { x: player.x, y: player.y };

    document.addEventListener("mousemove", (e) => {
      mousePos = { x: e.clientX, y: e.clientY };
    });

    const colorPicker = document.getElementById("playerColor");
    const colorPreview = document.getElementById("colorPreview");
    let leaderboard = JSON.parse(localStorage.getItem("leaderboard") || "[]");
    const socket = io("https://boxfighter.onrender.com/");

    colorPicker.addEventListener("input", (e) => {
      player.color = e.target.value;
      colorPreview.innerHTML = `<img src="player.png" style="width:40px;height:40px;filter: drop-shadow(0 0 10px ${e.target.value});" />`;
    });

    const enemyKillSound = document.getElementById("enemyKillSound");
    function playEnemyKillSound() {
      const soundClone = enemyKillSound.cloneNode();
      soundClone.volume = 1.0;
      soundClone.play().then(() => {});
    }

    const shootSound = document.getElementById("shootSound");
    const shootSoundPool = [];
    const poolSize = 5;
    let poolIndex = 0;
    for (let i = 0; i < poolSize; i++) {
      shootSoundPool.push(shootSound.cloneNode());
    }
    function playShootSound() {
      const sound = shootSoundPool[poolIndex];
      poolIndex = (poolIndex + 1) % poolSize;
      sound.currentTime = 0;
      sound.play().catch(err => console.error("Error playing shoot sound:", err));
    }

    let baseGamma = null;
    let baseBeta = null;
    const sensitivity = 0.2;

    function handleOrientation(event) {
      if (baseGamma === null || baseBeta === null) {
        baseGamma = event.gamma;
        baseBeta = event.beta;
        return;
      }
      const relativeGamma = event.gamma - baseGamma;
      const relativeBeta = event.beta - baseBeta;
      player.x += relativeGamma * sensitivity;
      player.y += relativeBeta * sensitivity;
      player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x));
      player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, player.y));
    }

    function enableAccelerometerControls() {
      if (window.DeviceOrientationEvent) {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          DeviceOrientationEvent.requestPermission()
            .then(permissionState => {
              if (permissionState === 'granted') {
                window.addEventListener("deviceorientation", handleOrientation);
                console.log("Accelerometer enabled.");
              }
            })
            .catch(console.error);
        } else {
          window.addEventListener("deviceorientation", handleOrientation);
          console.log("Accelerometer enabled.");
        }
      }
    }

    if (/Mobi|Android/i.test(navigator.userAgent)) {
      enableAccelerometerControls();
    }

    function getRandomSpawnPosition(minDistance = 200) {
      let x, y;
      do {
        x = Math.random() * canvas.width;
        y = Math.random() * canvas.height;
      } while (Math.hypot(x - player.x, y - player.y) < minDistance);
      return { x, y };
    }

    function updateBossHealthBars() {
      const bossBarContainer = document.getElementById("bossHealthBarContainer");
      const bossEnemies = enemies.filter(e => e.type === "boss");
      if (bossEnemies.length === 0) {
        bossBarContainer.style.display = "none";
      } else {
        bossBarContainer.style.display = "block";
        if (bossEnemies.length === 1) {
          const bar1 = document.getElementById("bossHealthBar1");
          bar1.style.width = (bossEnemies[0].hitsRemaining / 85 * 100) + "%";
          bar1.style.display = "block";
          document.getElementById("bossHealthBar2").style.display = "none";
        } else if (bossEnemies.length === 2) {
          const bar1 = document.getElementById("bossHealthBar1");
          const bar2 = document.getElementById("bossHealthBar2");
          bar1.style.width = (bossEnemies[0].hitsRemaining / 85 * 100) + "%";
          bar2.style.width = (bossEnemies[1].hitsRemaining / 85 * 100) + "%";
          bar1.style.display = "block";
          bar2.style.display = "block";
        }
      }
    }

    function pauseGame() {
      if (document.getElementById("gameOverScreen").style.display !== "none") {
          return;
      }
      if (!paused) {
          paused = true;
          if (gameLoopId) {
              cancelAnimationFrame(gameLoopId);
          }
          document.getElementById("bgMusic").pause();
          document.getElementById("startMenu").style.display = "flex";
          document.getElementById("gameUI").style.display = "none";
          document.getElementById("challengeTimer").style.display = "none";
      }
    }

    function startGame() {
      const canvas = document.getElementById("gameCanvas");
      canvas.style.cursor = "url('https://i.postimg.cc/gk1NVmNN/output-onlinepngtools.png') 30 30, crosshair";
      
      if (paused) {
        paused = false;
        document.getElementById("startMenu").style.display = "none";
        document.getElementById("gameUI").style.display = "block";
        if (gameMode === "challenge") {
          let pauseDuration = performance.now() - pausedTime;
          challengeStartTime += pauseDuration;
          document.getElementById("challengeTimer").style.display = "block";
          challengeTimerActive = true;
        }
        document.getElementById("bgMusic").play();
        gameLoop();
        return;
      }
    
      if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
      }
      if (/Mobi|Android/i.test(navigator.userAgent)) {
        if (typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function") {
          DeviceOrientationEvent.requestPermission()
            .then(permissionState => {
              if (permissionState === "granted") {
                window.addEventListener("deviceorientation", handleOrientation);
                console.log("Device orientation permission granted.");
              } else {
                console.log("Device orientation permission denied.");
              }
            })
            .catch(console.error);
        } else {
          window.addEventListener("deviceorientation", handleOrientation);
          console.log("Device orientation enabled (no permission needed).");
        }
      }
      const bgMusic = document.getElementById("bgMusic");
      bgMusic.currentTime = 0;
      bgMusic.play();
      document.getElementById("startMenu").style.display = "none";
      document.getElementById("gameUI").style.display = "block";
      document.getElementById("gameOverScreen").style.display = "none";
      document.getElementById("bossHealthBarContainer").style.display = "none";
      health = 100;
      score = 0;
      enemies = [];
      healthBoosts = [];
      coinsOnField = [];
      enemyBullets = [];
      roundNumber = 1;
      nextWaveTime = performance.now();
      waveStarted = false;
      enemiesSpawnedForWave = false;
      if (gameMode !== "challenge" && gameMode !== "pvp") {
        welcomePhase = true;
        welcomePhaseEndTime = performance.now() + 5000;
        document.getElementById("roundMessage").textContent = "Welcome Agent B-XFTR";
        document.getElementById("roundMessage").style.opacity = 1;
        document.getElementById("challengeTimer").style.display = "none";
      } else if (gameMode === "challenge") {
        welcomePhase = false;
        document.getElementById("roundMessage").style.opacity = 0;
        challengeStartTime = performance.now();
        lastChallengeSpawnTime = performance.now();
        challengeTimerActive = true;
        document.getElementById("challengeTimer").style.display = "block";
      } else if (gameMode === "pvp") {
        // In PVP mode, connect to the multiplayer server.
        document.getElementById("roundMessage").textContent = "PVP Mode: Waiting for opponent...";
        document.getElementById("roundMessage").style.opacity = 1;
        // Replace the URL below with your server's address (if running locally, use http://localhost:3000)
       const socket = io("https://boxfighter.onrender.com/");

 
// Receive the list of current players (including yourself)
socket.on('currentPlayers', (players) => {
  // 'players' is an object keyed by socket IDs.
  // Add every other player to our local state.
  Object.keys(players).forEach((id) => {
    if (id !== socket.id) {
      otherPlayers[id] = players[id];
    }
  });
});

// When a new player joins
socket.on('newPlayer', (playerData) => {
    otherPlayers[playerData.id] = playerData;
    console.log("New player added:", playerData);
});

// When an existing player moves
socket.on('playerMove', (data) => {
    // Update the position of the other player
    if (otherPlayers[data.id]) {
        otherPlayers[data.id].x = data.data.x;
        otherPlayers[data.id].y = data.data.y;
    }
});


// When a player disconnects
socket.on('playerDisconnect', (id) => {
  delete otherPlayers[id];
  console.log("Player disconnected:", id);
});

socket.on("respawn", (playerData) => {
  otherPlayers[playerData.id] = playerData; // Update respawned player
});

        socket.on("playerShoot", (data) => {
  // Handle bullets shot by other players
  const otherPlayer = otherPlayers[data.id];
  if (otherPlayer) {
    // Draw other player’s bullets (implement this similar to your own shooting)
    drawBullet(data.data);  // You need to handle bullet drawing for other players as well
  }
});

// Update the respawn timer
socket.on('respawn', (playerData) => {
  // Respawn the player after 5 seconds
  player.x = canvas.width / 2;
  player.y = canvas.height / 2;
  // Reset other player state as needed
});

// Handle player disconnection
socket.on("playerDisconnect", (id) => {
  delete otherPlayers[id];  // Remove the disconnected player
});

// Show respawn timer on screen



// Send your shoot event to the server
function shootBullet() {
  // Your shooting logic
  socket.emit("playerShoot", { id: socket.id, data: bulletData });
}


  // Later in your game loop, you can emit your own events. For example:
  // socket.emit("playerMove", { x: player.x, y: player.y });
  // socket.emit("playerShoot", { bulletData: ... });
}
      gameStarted = true;
      if (gameMode === "challenge") {
        challengeStartTime = performance.now();
        lastChallengeSpawnTime = performance.now();
        challengeTimerActive = true;
        document.getElementById("challengeTimer").style.display = "block";
      } else {
        document.getElementById("challengeTimer").style.display = "none";
      }
      displayLeaderboard();
      gameLoop();
    }
    
    function restartGame() {
      startGame();
    }
    
    function spawnHealthBoost() {
      if (Math.random() < 0.25) {
        healthBoosts.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: 13,
          color: "hotpink"
        });
      }
    }
    
    function spawnCoin() {
      if (Math.random() < 0.25) {
        coinsOnField.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: 10,
          color: "goldenrod"
        });
      }
    }
    
    function drawPlayer() {
      let angle = Math.atan2(mousePos.y - player.y, mousePos.x - player.x) - Math.PI/2;
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(angle);
      ctx.shadowColor = player.color;
      ctx.shadowBlur = 50;
      ctx.drawImage(playerImage, -player.size/2, -player.size/2, player.size, player.size);
      ctx.restore();
    }
    let otherPlayers = {};
   
function drawOtherPlayers() {
    for (let id in otherPlayers) {
        const otherPlayer = otherPlayers[id];
    
        
        // Check if the player is within canvas bounds
        if (otherPlayer.x >= 0 && otherPlayer.x <= canvas.width && otherPlayer.y >= 0 && otherPlayer.y <= canvas.height) {
            ctx.save();
            ctx.translate(otherPlayer.x, otherPlayer.y);
            ctx.drawImage(playerImage, -otherPlayer.size / 2, -otherPlayer.size / 2, otherPlayer.size, otherPlayer.size);
            ctx.restore();
        }
    }
}

    function drawEnemies() {
      for (let enemy of enemies) {
        ctx.shadowColor = enemy.type === "boss" ? "white" :
                          enemy.type === "tank" ? "yellow" : 
                          enemy.type === "clone" ? "white" : "red";
        ctx.shadowBlur = 5;
        ctx.fillStyle = enemy.color;
        ctx.fillRect(
          enemy.x - enemy.size / 2,
          enemy.y - enemy.size / 2,
          enemy.size,
          enemy.size
        );
        ctx.shadowBlur = 5;
        if (enemy.type === "boss") {
          for (let bullet of enemy.bullets) {
            ctx.fillStyle = "purple";
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowColor = "transparent";
            ctx.shadowBlur = 0;
          }
        }
      }
    }
    
    function drawShield() {
      if (shieldActive) {
        const shieldRadius = player.size / 2 + 17;
        ctx.beginPath();
        ctx.arc(player.x, player.y, shieldRadius, 0, Math.PI * 2);
        ctx.strokeStyle = getShieldColor();
        ctx.lineWidth = 10;
        ctx.shadowColor = getShieldColor();
        ctx.shadowBlur = 20;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }

    function getShieldColor() {
      if (shieldDurability === 3) return "#00FFFF";
      else if (shieldDurability === 2) return "yellow";
      else if (shieldDurability === 1) return "red";
      else return "#00FFFF";
    }
    
    function updateBullets() {
      for (let i = player.bullets.length - 1; i >= 0; i--) {
        const bullet = player.bullets[i];
        if (bullet.lifetime && performance.now() - bullet.creationTime >= bullet.lifetime) {
          player.bullets.splice(i, 1);
          continue;
        }
        bullet.x += bullet.dx;
        bullet.y += bullet.dy;
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
          player.bullets.splice(i, 1);
        }
      }
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const bullet = enemyBullets[i];
        bullet.x += bullet.dx;
        bullet.y += bullet.dy;
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
          enemyBullets.splice(i, 1);
        }
      }
      for (let enemy of enemies) {
        if (enemy.type === "boss") {
          for (let i = enemy.bullets.length - 1; i >= 0; i--) {
            const bullet = enemy.bullets[i];
            bullet.x += bullet.dx;
            bullet.y += bullet.dy;
            if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
              enemy.bullets.splice(i, 1);
            }
          }
        }
      }
    }
    
    function drawHealthBoosts() {
      for (let boost of healthBoosts) {
        ctx.shadowColor = "green";
        ctx.shadowBlur = 5;
        ctx.fillStyle = boost.color;
        ctx.beginPath();
        ctx.arc(boost.x, boost.y, boost.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function drawCoins() {
      for (let coin of coinsOnField) {
        ctx.shadowColor = "gold";
        ctx.shadowBlur = 5;
        ctx.fillStyle = coin.color;
        ctx.beginPath();
        ctx.arc(coin.x, coin.y, coin.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function drawBullets() {
      for (let bullet of player.bullets) {
        if (bullet.flamethrower) {
          ctx.shadowColor = "red";
          ctx.shadowBlur = 8;
          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, 10, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.shadowColor = "red";
          ctx.shadowBlur = 8;
          ctx.fillStyle = "black";
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      for (let bullet of enemyBullets) {
        ctx.shadowColor = "darkblue";
        ctx.shadowBlur = 8;
        ctx.fillStyle = "darkblue";
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function updatePlayer() {
      let speed = 4;
      if (keys["w"] && player.y - player.size / 2 > 0) player.y -= speed;
      if (keys["s"] && player.y + player.size / 2 < canvas.height) player.y += speed;
      if (keys["a"] && player.x - player.size / 2 > 0) player.x -= speed;
      if (keys["d"] && player.x + player.size / 2 < canvas.width) player.x += speed;

      socket.emit('playerMove', { x: player.x, y: player.y });
    }
    
    function normalizeAngle(angle) {
      while(angle > Math.PI) angle -= 2 * Math.PI;
      while(angle < -Math.PI) angle += 2 * Math.PI;
      return angle;
    }
    
    function isInShieldZone(x, y) {
      let angleToPoint = Math.atan2(y - player.y, x - player.x);
      let shieldAngle = Math.atan2(mousePos.y - player.y, mousePos.x - player.x) - Math.PI/2;
      let diff = Math.abs(normalizeAngle(angleToPoint - shieldAngle));
      return diff < 0.785;
    }
    
    function updateEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (enemy.type === "clone") {
          if (enemy.isSplitting) {
            enemy.x += enemy.dx;
            enemy.y += enemy.dy;
            if (performance.now() >= enemy.splitTime) {
              enemy.isSplitting = false;
              enemy.dx = 0;
              enemy.dy = 0;
            }
          } else {
            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
            enemy.x += Math.cos(angle) * enemy.speed;
            enemy.y += Math.sin(angle) * enemy.speed;
          }
        } else {
          const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
          enemy.x += Math.cos(angle) * enemy.speed;
          enemy.y += Math.sin(angle) * enemy.speed;
        }
        if (
          player.x + player.size/2 > enemy.x - enemy.size/2 &&
          player.x - player.size/2 < enemy.x + enemy.size/2 &&
          player.y + player.size/2 > enemy.y - enemy.size/2 &&
          player.y - player.size/2 < enemy.y + enemy.size/2
        ) {
          if (shieldActive) {
            shieldHit();
            if (enemy.shootInterval) {
              clearInterval(enemy.shootInterval);
            }
            enemies.splice(i, 1);
          } else {
            if (enemy.type === "boss") {
              health = 0;
            }
            health -= 30;
            if (enemy.shootInterval) {
              clearInterval(enemy.shootInterval);
            }
            enemies.splice(i, 1);
            if (health <= 0) {
              endGame();
              return;
            }
          }
        }
      }
    }
    
    function shootAtPlayer(enemy) {
      const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
      const bullet = {
        x: enemy.x,
        y: enemy.y,
        dx: Math.cos(angle) * 5,
        dy: Math.sin(angle) * 5,
        size: 5,
        color: enemy.type === "boss" ? "purple" : "darkblue"
      };
      if (enemy.type === "shooter") {
        enemyBullets.push(bullet);
      } else {
        enemy.bullets.push(bullet);
      }
    }
    
    function bossShoot(enemy) {
      const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
      const aimedBullet = {
        x: enemy.x,
        y: enemy.y,
        dx: Math.cos(angle) * 6,
        dy: Math.sin(angle) * 6,
        size: 10,
        color: "purple"
      };
      enemy.bullets.push(aimedBullet);
      const bulletCount = 12;
      const bulletSpeed = 4;
      for (let i = 0; i < bulletCount; i++) {
        const ringAngle = (2 * Math.PI * i) / bulletCount;
        const ringBullet = {
          x: enemy.x,
          y: enemy.y,
          dx: Math.cos(ringAngle) * bulletSpeed,
          dy: Math.sin(ringAngle) * bulletSpeed,
          size: 5,
          color: "purple"
        };
        enemy.bullets.push(ringBullet);
      }
    }
    
    function initBoss(enemy) {
      enemy.aimedShootInterval = setInterval(() => {
        if (enemies.indexOf(enemy) !== -1) {
          const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
          const aimedBullet = {
            x: enemy.x,
            y: enemy.y,
            dx: Math.cos(angle) * 5,
            dy: Math.sin(angle) * 5,
            size: 5,
            color: "purple"
          };
          enemy.bullets.push(aimedBullet);
        } else {
          clearInterval(enemy.aimedShootInterval);
        }
      }, 1500);
    
      enemy.ringShootInterval = setInterval(() => {
        if (enemies.indexOf(enemy) !== -1) {
          const bulletCount = 12;
          const bulletSpeed = 4;
          for (let i = 0; i < bulletCount; i++) {
            const ringAngle = (2 * Math.PI * i) / bulletCount;
            const ringBullet = {
              x: enemy.x,
              y: enemy.y,
              dx: Math.cos(ringAngle) * bulletSpeed,
              dy: Math.sin(ringAngle) * bulletSpeed,
              size: 5,
              color: "purple"
            };
            enemy.bullets.push(ringBullet);
          }
        } else {
          clearInterval(enemy.ringShootInterval);
        }
      }, 3000);
    }
    
    function checkBulletCollisions() {
      for (let i = player.bullets.length - 1; i >= 0; i--) {
        const bullet = player.bullets[i];
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          if (
            bullet.x >= enemy.x - enemy.size / 2 &&
            bullet.x <= enemy.x + enemy.size / 2 &&
            bullet.y >= enemy.y - enemy.size / 2 &&
            bullet.y <= enemy.y + enemy.size / 2
          ) {
            if (enemy.type === "tank") {
              enemy.hitsRemaining--;
              player.bullets.splice(i, 1);
              if (enemy.hitsRemaining <= 0) {
                score += 15;
                health = Math.min(100, health + 5);
                enemies.splice(j, 1);
                playEnemyKillSound();
              }
              break;
            } else if (enemy.type === "shooter") {
              enemy.hitsRemaining--;
              player.bullets.splice(i, 1);
              if (enemy.hitsRemaining <= 0) {
                score += 10;
                enemies.splice(j, 1);
                playEnemyKillSound();
              }
            } else if (enemy.type === "boss") {
              enemy.hitsRemaining--;
              player.bullets.splice(i, 1);
              if (enemy.hitsRemaining <= 0) {
                score += 50;
                clearInterval(enemy.shootInterval);
                enemyBullets.push(...enemy.bullets);
                enemy.bullets = [];
                enemies.splice(j, 1);
              }
              break;
            } else if (enemy.type === "clone") {
              if (enemy.canClone) {
                const baseAngle = Math.random() * 2 * Math.PI;
                const splitSpeed = 5;
                const currentTime = performance.now();
                const clone1 = {
                  x: enemy.x,
                  y: enemy.y,
                  type: "clone",
                  size: enemy.size / 2,
                  color: "white",
                  speed: enemy.speed,
                  canClone: false,
                  isSplitting: true,
                  splitTime: currentTime + 500,
                  dx: Math.cos(baseAngle + 0.3) * splitSpeed,
                  dy: Math.sin(baseAngle + 0.3) * splitSpeed
                };
                const clone2 = {
                  x: enemy.x,
                  y: enemy.y,
                  type: "clone",
                  size: enemy.size / 2,
                  color: "white",
                  speed: enemy.speed,
                  canClone: false,
                  isSplitting: true,
                  splitTime: currentTime + 500,
                  dx: Math.cos(baseAngle - 0.3) * splitSpeed,
                  dy: Math.sin(baseAngle - 0.3) * splitSpeed
                };
                enemies.splice(j, 1);
                enemies.push(clone1, clone2);
                score += 15;
                health = Math.min(100, health + 5);
                player.bullets.splice(i, 1);
                playEnemyKillSound();
                break;
              } else {
                score += 15;
                health = Math.min(100, health + 5);
                player.bullets.splice(i, 1);
                enemies.splice(j, 1);
                playEnemyKillSound();
                break;
              }
            } else {
              score += 15;
              health = Math.min(100, health + 5);
              player.bullets.splice(i, 1);
              enemies.splice(j, 1);
              playEnemyKillSound();
              break;
            }
          }
        }
      }
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const bullet = enemyBullets[i];
        if (Math.hypot(bullet.x - player.x, bullet.y - player.y) < player.size / 2 + bullet.size) {
          if (isInShieldZone(bullet.x, bullet.y) && shieldActive) {
            shieldHit();
            enemyBullets.splice(i, 1);
          } else {
            health -= health * 0.25;
            enemyBullets.splice(i, 1);
            if (health <= 0) {
              endGame();
            }
          }
        }
      }
      for (let enemy of enemies) {
        if (enemy.type === "boss") {
          for (let i = enemy.bullets.length - 1; i >= 0; i--) {
            const bullet = enemy.bullets[i];
            if (Math.hypot(bullet.x - player.x, bullet.y - player.y) < player.size / 2 + bullet.size) {
              if (isInShieldZone(bullet.x, bullet.y) && shieldActive) {
                shieldHit();
                enemy.bullets.splice(i, 1);
              } else {
                health -= health * 0.25;
                enemy.bullets.splice(i, 1);
                if (health <= 0) {
                  endGame();
                }
              }
            }
          }
        }
      }
    }
    
    function checkHealthBoostCollisions() {
      for (let i = healthBoosts.length - 1; i >= 0; i--) {
        const boost = healthBoosts[i];
        if (Math.hypot(player.x - boost.x, player.y - boost.y) < (player.size + boost.size) / 2) {
          health = Math.min(100, health + 20);
          healthBoosts.splice(i, 1);
        }
      }
    }
    
    function checkCoinCollisions() {
      for (let i = coinsOnField.length - 1; i >= 0; i--) {
        const coin = coinsOnField[i];
        if (Math.hypot(player.x - coin.x, player.y - coin.y) < (player.size + coin.size) / 2) {
          coinCount++;
          localStorage.setItem("coinCount", coinCount);
          updateCoinCounters();
          coinsOnField.splice(i, 1);
        }
      }
    }
    
    function updateHealthBar() {
      const healthBarInner = document.getElementById("healthBarInner");
      healthBarInner.style.width = `${health}%`;
      healthBarInner.style.backgroundColor = health > 50 ? "green" : "orange";
    }
    
    function shieldHit() {
      shieldDurability--;
      if (shieldDurability <= 0) {
        shieldActive = false;
        startShieldCooldown();
      }
    }
    
    function startShieldCooldown() {
      shieldCooldownActive = true;
      shieldCooldownStart = performance.now();
      document.getElementById("shieldCooldownBox").style.display = "block";
    }
    function checkHealth() {
  if (health <= 0) {
    endGame();
    // Send a "playerDied" event to notify the server
    socket.emit('playerDied');
  }
}
// Function to show respawn timer
function showRespawnTimer(timeLeft) {
  const respawnTimerElement = document.getElementById("respawnTimer");
  respawnTimerElement.textContent = `Respawning in ${timeLeft} seconds`; // Update the timer text
}

    function endGame() {
      if (gameMode === "challenge") {
        challengeTimerActive = false;
        document.getElementById("challengeTimer").style.display = "none";
      }
      document.getElementById("gameOverScreen").style.display = "flex";
      document.getElementById("respawnTimer").style.display = "block"; // Show respawn timer text

      document.getElementById("finalScore").textContent = `Final Score: ${score}`;
      updateLeaderboard(score);
     let respawnTime = 5; // 5 seconds respawn timer
  let interval = setInterval(() => {
    showRespawnTimer(respawnTime);
    respawnTime--;
    if (respawnTime <= 0) {
      clearInterval(interval);
      socket.emit('playerRespawn');  // Trigger respawn logic
    }
  }, 1000);
}
    
    function handleWaveLogic(timestamp) {
      if (gameMode !== "zombies") {
        return;
      }
      if (welcomePhase) {
        if (timestamp >= welcomePhaseEndTime) {
          welcomePhase = false;
          nextWaveTime = timestamp;
          waveStarted = false;
          enemiesSpawnedForWave = false;
        } else {
          document.getElementById("roundMessage").textContent = "Welcome Agent B-XFTR";
          document.getElementById("roundMessage").style.opacity = 1;
          return;
        }
      }
      if (timestamp >= nextWaveTime) {
        if (!waveStarted) {
          waveStartTime = timestamp;
          if (roundNumber === 5) {
            document.getElementById("roundMessage").textContent = "Boss Incoming";
          } else {
            document.getElementById("roundMessage").textContent = "Wave " + roundNumber;
          }
          document.getElementById("roundMessage").style.opacity = 1;
          waveStarted = true;
        }
        if (timestamp >= waveStartTime + waveMessageDuration && !enemiesSpawnedForWave) {
          if (roundNumber === 5) {
            let bossEnemy = {
              x: canvas.width / 2,
              y: canvas.height / 4,
              type: "boss",
              size: 120,
              color: "darkred",
              speed: 2.35,
              hitsRemaining: 85,
              bullets: []
            };
            initBoss(bossEnemy);
            enemies.push(bossEnemy);
          } else {
            spawnEnemies();
            spawnHealthBoost();
            spawnCoin();
            if (roundNumber > 10 && Math.random() < 0.3) {
              let extraBoss = {
                x: canvas.width / 2,
                y: canvas.height / 4,
                type: "boss",
                size: 120,
                color: "darkred",
                speed: 2.35,
                hitsRemaining: 85,
                bullets: []
              };
              initBoss(extraBoss);
              enemies.push(extraBoss);
            }
          }
          enemiesSpawnedForWave = true;
          document.getElementById("roundMessage").style.opacity = 0;
        }
        if (timestamp >= nextWaveTime + waveInterval) {
          roundNumber++;
          nextWaveTime = timestamp;
          waveStarted = false;
          enemiesSpawnedForWave = false;
        }
      }
    }
    
    function handleChallengeMode(timestamp) {
      if (!challengeTimerActive) {
        return;
      }
      if (health <= 0) {
        challengeTimerActive = false;
        return;
      }
      let elapsed = timestamp - challengeStartTime;
      if (elapsed >= 300000) {
        enemies = [];
        enemyBullets = [];
        document.getElementById("roundMessage").textContent = "You Win!";
        document.getElementById("roundMessage").style.opacity = 1;
        challengeTimerActive = false;
        setTimeout(() => {
          endChallengeMode();
        }, 10000);
      } else {
        if (timestamp - lastChallengeSpawnTime >= 1000) {
          spawnSingleEnemy();
          lastChallengeSpawnTime = timestamp;
        }
        let remaining = 300000 - elapsed;
        let minutes = Math.floor(remaining / 60000);
        let seconds = Math.floor((remaining % 60000) / 1000);
        document.getElementById("challengeTimer").textContent = `Time Left: ${minutes}:${seconds < 10 ? "0" + seconds : seconds}`;
      }
    }
    
    function spawnSingleEnemy() {
      const types = ["melee", "shooter", "tank", "clone", "boss"];
      const type = types[Math.floor(Math.random() * types.length)];
      const pos = getRandomSpawnPosition(100);
      let enemy = {
        x: pos.x,
        y: pos.y,
        type: type,
        dx: 0,
        dy: 0,
        bullets: []
      };
      if (type === "shooter") {
        enemy.size = 40;
        enemy.color = "darkblue";
        enemy.speed = 1.75;
        enemy.hitsRemaining = 2;
        enemy.shootCooldown = 0;
        enemy.shootInterval = setInterval(() => {
          if (enemies.indexOf(enemy) !== -1) {
            shootAtPlayer(enemy);
          } else {
            clearInterval(enemy.shootInterval);
          }
        }, 800);
      } else if (type === "tank") {
        enemy.size = 60;
        enemy.color = "yellow";
        enemy.speed = 1.25;
        enemy.hitsRemaining = 5;
      } else if (type === "clone") {
        enemy.size = 30;
        enemy.color = "white";
        enemy.speed = 2.35;
        enemy.canClone = true;
        enemy.isSplitting = false;
      } else if (type === "boss") {
        enemy.size = 120;
        enemy.color = "darkred";
        enemy.speed = 2.35;
        enemy.hitsRemaining = 85;
        initBoss(enemy);
      } else {
        enemy.size = 30;
        enemy.color = "red";
        enemy.speed = 2.35;
      }
      enemies.push(enemy);
    }
    
    function endChallengeMode() {
      pauseGame();
      document.getElementById("roundMessage").style.opacity = 0;
      challengeTimerActive = false;
    }
    
   
    
    
    function gameLoop(timestamp) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (shieldCooldownActive) {
        let elapsed = (performance.now() - shieldCooldownStart) / 1000;
        let remaining = Math.max(0, 10 - elapsed);
        let cooldownBox = document.getElementById("shieldCooldownBox");
        cooldownBox.textContent = `Shield Cooldown: ${remaining.toFixed(1)}s`;
        if (remaining <= 0) {
          shieldCooldownActive = false;
          cooldownBox.style.display = "none";
        }
      }
      
      if (gameMode === "challenge" && !paused) {
        handleChallengeMode(timestamp);
      } else {
        handleWaveLogic(timestamp);
      }
      updatePlayer();
      updateBullets();
      updateEnemies();
      checkBulletCollisions();
      checkHealthBoostCollisions();
      checkCoinCollisions();
      updateHealthBar();
      updateBossHealthBars();
      
      drawPlayer();
      drawShield();
      drawEnemies();
      drawBullets();
      drawHealthBoosts();
      drawCoins();
      drawOtherPlayers(); 
      
      document.getElementById("score").textContent = `Score: ${score}`;
      
      gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    window.addEventListener("keydown", (e) => (keys[e.key] = true));
    window.addEventListener("keyup", (e) => (keys[e.key] = false));
    
    document.addEventListener("keydown", function(e) {
      if (e.key === "Escape") {
        pauseGame();
      }
    });
    
    document.addEventListener("keydown", function(e) {
      if (e.code === "Space") {
        if (shieldEquipped && !shieldActive && !shieldCooldownActive) {
          activateShield();
        }
      }
    });
    
    function activateShield() {
      shieldActive = true;
      shieldDurability = 3;
    }
    
    let flamethrowerInterval = null;
    let lastMousePos = { x: player.x, y: player.y };
    
    canvas.addEventListener("click", (e) => {
      if (playerGun !== "flamethrower") {
        playShootSound();
        const angle = Math.atan2(e.clientY - player.y, e.clientX - player.x);
        if (playerGun === "shotgun") {
          const spread = 0.2;
          player.bullets.push({
            x: player.x,
            y: player.y,
            dx: Math.cos(angle) * 6.5,
            dy: Math.sin(angle) * 6.5
          });
          player.bullets.push({
            x: player.x,
            y: player.y,
            dx: Math.cos(angle - spread) * 6.5,
            dy: Math.sin(angle - spread) * 6.5
          });
          player.bullets.push({
            x: player.x,
            y: player.y,
            dx: Math.cos(angle + spread) * 6.5,
            dy: Math.sin(angle + spread) * 6.5
          });
        } else if (playerGun === "uzi") {
          for (let i = 0; i < 5; i++) {
            setTimeout(() => {
              let deviation = (Math.random() - 0.5) * 0.2;
              let bulletAngle = angle + deviation;
              player.bullets.push({
                x: player.x,
                y: player.y,
                dx: Math.cos(bulletAngle) * 6.5,
                dy: Math.sin(bulletAngle) * 6.5
              });
            }, i * 50);
          }
        } else {
          player.bullets.push({
            x: player.x,
            y: player.y,
            dx: Math.cos(angle) * 6.5,
            dy: Math.sin(angle) * 6.5
          });
        }
      }
    });
    
    canvas.addEventListener("mousedown", function(e) {
      if (playerGun === "flamethrower") {
        lastMousePos = { x: e.clientX, y: e.clientY };
        if (!flamethrowerInterval) {
          flamethrowerInterval = setInterval(shootFlame, 100);
        }
      }
    });
    canvas.addEventListener("mouseup", function(e) {
      if (playerGun === "flamethrower" && flamethrowerInterval) {
        clearInterval(flamethrowerInterval);
        flamethrowerInterval = null;
      }
    });
    canvas.addEventListener("mousemove", function(e) {
      if (playerGun === "flamethrower") {
        lastMousePos = { x: e.clientX, y: e.clientY };
      }
    });
    
    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      if (playerGun === "flamethrower") {
        let touch = e.changedTouches[0];
        lastMousePos = { x: touch.clientX, y: touch.clientY };
        if (!flamethrowerInterval) {
          flamethrowerInterval = setInterval(shootFlame, 100);
        }
      } else {
        playShootSound();
        for (let touch of e.changedTouches) {
          const angle = Math.atan2(touch.clientY - player.y, touch.clientX - player.x);
          if (playerGun === "shotgun") {
            const spread = 0.2;
            player.bullets.push({
              x: player.x,
              y: player.y,
              dx: Math.cos(angle) * 6.5,
              dy: Math.sin(angle) * 6.5
            });
            player.bullets.push({
              x: player.x,
              y: player.y,
              dx: Math.cos(angle - spread) * 6.5,
              dy: Math.sin(angle - spread) * 6.5
            });
            player.bullets.push({
              x: player.x,
              y: player.y,
              dx: Math.cos(angle + spread) * 6.5,
              dy: Math.sin(angle + spread) * 6.5
            });
          } else if (playerGun === "uzi") {
            for (let i = 0; i < 5; i++) {
              setTimeout(() => {
                let deviation = (Math.random() - 0.5) * 0.2;
                let bulletAngle = angle + deviation;
                player.bullets.push({
                  x: player.x,
                  y: player.y,
                  dx: Math.cos(bulletAngle) * 6.5,
                  dy: Math.sin(bulletAngle) * 6.5
                });
              }, i * 100);
            }
          } else {
            player.bullets.push({
              x: player.x,
              y: player.y,
              dx: Math.cos(angle) * 6.5,
              dy: Math.sin(angle) * 6.5
            });
          }
        }
      }
    }, { passive: false });
    
    canvas.addEventListener("touchend", (e) => {
      if (playerGun === "flamethrower" && flamethrowerInterval) {
        clearInterval(flamethrowerInterval);
        flamethrowerInterval = null;
      }
    });
    
    canvas.addEventListener("touchmove", (e) => {
      if (playerGun === "flamethrower") {
        let touch = e.touches[0];
        lastMousePos = { x: touch.clientX, y: touch.clientY };
      }
    });
    
    function shootFlame() {
      let baseAngle = Math.atan2(lastMousePos.y - player.y, lastMousePos.x - player.x) || 0;
      const spread = 0.2;
      const speed = 4;
      for (let i = -2; i <= 2; i++) {
        let bulletAngle = baseAngle + i * spread;
        player.bullets.push({
          x: player.x,
          y: player.y,
          dx: Math.cos(bulletAngle) * speed,
          dy: Math.sin(bulletAngle) * speed,
          lifetime: 500,
          creationTime: performance.now(),
          flamethrower: true
        });
      }
    }
    
    function spawnEnemies() {
      let numberOfEnemies = 8 + roundNumber - 1;
      for (let i = 0; i < numberOfEnemies; i++) {
        let r = Math.random();
        let type;
        if (roundNumber >= 5 && r > 0.8) {
          type = "clone";
        } else if (r < 0.15) {
          type = "tank";
        } else if (r < 0.4) {
          type = "shooter";
        } else {
          type = "melee";
        }
        let enemy = {
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          type: type,
          dx: 0,
          dy: 0,
          bullets: []
        };
        if (type === "shooter") {
          enemy.size = 40;
          enemy.color = "darkblue";
          enemy.speed = 1.75;
          enemy.hitsRemaining = 2;
          enemy.shootCooldown = 0;
          enemy.shootInterval = setInterval(() => {
            if (enemies.indexOf(enemy) !== -1) {
              shootAtPlayer(enemy);
            } else {
              clearInterval(enemy.shootInterval);
            }
          }, 800);
        } else if (type === "tank") {
          enemy.size = 60;
          enemy.color = "yellow";
          enemy.speed = 1.25;
          enemy.hitsRemaining = 5;
        } else if (type === "clone") {
          enemy.size = 30;
          enemy.color = "white";
          enemy.speed = 2.35;
          enemy.canClone = true;
          enemy.isSplitting = false;
        } else {
          enemy.size = 30;
          enemy.color = "red";
          enemy.speed = 2.35;
        }
        enemies.push(enemy);
      }
    }
    
    function updateLeaderboard(score) {
      leaderboard.push(score);
      leaderboard.sort((a, b) => b - a);
      leaderboard = leaderboard.slice(0, 5);
      localStorage.setItem("leaderboard", JSON.stringify(leaderboard));
      displayLeaderboard();
    }
    
    function displayLeaderboard() {
      const leaderboardList = document.getElementById("leaderboardList");
      leaderboardList.innerHTML = "";
      leaderboard.forEach((score, index) => {
        const li = document.createElement("li");
        li.textContent = `${index + 1}. ${score}`;
        leaderboardList.appendChild(li);
      });
    }
    
    displayLeaderboard();
    
    function toggleMusic() {
      const bgMusic = document.getElementById("bgMusic");
      const muteButton = document.getElementById("muteButton");
      if (bgMusic.muted) {
        bgMusic.muted = false;
        muteButton.textContent = "Mute Music";
      } else {
        bgMusic.muted = true;
        muteButton.textContent = "Unmute Music";
      }
    }
    
    function openGunShop() {
      document.getElementById("gunShopModal").style.display = "block";
    }
    
    function closeGunShop() {
      document.getElementById("gunShopModal").style.display = "none";
    }
    
    function selectGun(gun) {
      if (gun === "rifle") {
        playerGun = "rifle";
        shieldEquipped = false;
        alert("Rifle equipped!");
      } else if (gun === "shield") {
        if (ownedGuns.includes("shield")) {
          shieldEquipped = true;
          alert("Shield equipped! (Press Space to deploy)");
        } else {
          if (coinCount * 50 >= 5000) {
            coinCount -= 100;
            localStorage.setItem("coinCount", coinCount);
            updateCoinCounters();
            shieldEquipped = true;
            ownedGuns.push("shield");
            localStorage.setItem("ownedGuns", JSON.stringify(ownedGuns));
            alert("Shield purchased and equipped! (Press Space to deploy)");
          } else {
            alert("Not enough coins for Shield!");
          }
        }
      } else {
        if (ownedGuns.includes(gun)) {
          playerGun = gun;
          shieldEquipped = false;
          alert(gun.charAt(0).toUpperCase() + gun.slice(1) + " equipped!");
        } else {
          if (gun === "shotgun") {
            if (coinCount * 50 >= 300) {
              coinCount -= 6;
              localStorage.setItem("coinCount", coinCount);
              updateCoinCounters();
              playerGun = "shotgun";
              shieldEquipped = false;
              ownedGuns.push("shotgun");
              localStorage.setItem("ownedGuns", JSON.stringify(ownedGuns));
              alert("Shotgun purchased and equipped!");
            } else {
              alert("Not enough coins for Shotgun!");
            }
          } else if (gun === "flamethrower") {
            if (coinCount * 50 >= 1000) {
              coinCount -= 20;
              localStorage.setItem("coinCount", coinCount);
              updateCoinCounters();
              playerGun = "flamethrower";
              shieldEquipped = false;
              ownedGuns.push("flamethrower");
              localStorage.setItem("ownedGuns", JSON.stringify(ownedGuns));
              alert("Flamethrower purchased and equipped!");
            } else {
              alert("Not enough coins for Flamethrower!");
            }
          } else if (gun === "uzi") {
            if (coinCount * 50 >= 2000) {
              coinCount -= 40;
              localStorage.setItem("coinCount", coinCount);
              updateCoinCounters();
              playerGun = "uzi";
              shieldEquipped = false;
              ownedGuns.push("uzi");
              localStorage.setItem("ownedGuns", JSON.stringify(ownedGuns));
              alert("Uzi purchased and equipped!");
            } else {
              alert("Not enough coins for Uzi!");
            }
          }
        }
      }
      closeGunShop();
    }
    
    function openGameModeBox() {
      document.getElementById("gameModeModal").style.display = "block";
    }
    
    function closeGameMode() {
      document.getElementById("gameModeModal").style.display = "none";
    }
    
    function selectGameMode(mode) {
      gameMode = mode;
      enemies = [];
      enemyBullets = [];
      healthBoosts = [];
      coinsOnField = [];
      
      if (gameMode === "zombies") {
        challengeStartTime = 0;
        lastChallengeSpawnTime = 0;
        challengeTimerActive = false;
        roundNumber = 1;
        nextWaveTime = performance.now();
        welcomePhase = true;
        welcomePhaseEndTime = performance.now() + 5000;
        document.getElementById("roundMessage").textContent = "Welcome Agent B-XFTR";
        document.getElementById("roundMessage").style.opacity = 1;
      } else if (gameMode === "challenge") {
        document.getElementById("roundMessage").style.opacity = 0;
        challengeStartTime = performance.now();
        lastChallengeSpawnTime = performance.now();
        challengeTimerActive = true;
      } else if (gameMode === "pvp") {
        document.getElementById("roundMessage").textContent = "PVP Mode: Waiting for opponent...";
        document.getElementById("roundMessage").style.opacity = 1;
      }
      
      if (gameStarted) {
        pauseGame();
      }
      
      closeGameMode();
      alert("Game mode switched to " + (mode === "zombies" ? "Zombies" : mode === "challenge" ? "Challenge Mode" : "PVP") + ". Ready up to start.");
    }
    
  </script>
</body>
</html>
